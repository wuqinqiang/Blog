<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>记得</title>
    <link>https://www.syst.top/</link>
    <description>Recent content on 记得</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 10 Apr 2021 09:54:52 +0800</lastBuildDate><atom:link href="https://www.syst.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>etcd 实战基础篇(一) </title>
      <link>https://www.syst.top/posts/go/etcd-2021-04-10/</link>
      <pubDate>Sat, 10 Apr 2021 09:54:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/etcd-2021-04-10/</guid>
      <description>最近一直在看 etcd 相关的东西，为了不&amp;quot;白看&amp;quot;，加深理解，随即开启此系列的输出。
Etcd是什么 Etcd 是由 Go 编写的。它是一个强一致性的分布式键值存储，提供一种可靠的方式来存储需要由分布式系统或者机器集群访问的数据。 同时 Etcd 各节点中的通信是通过 Raft 一致性算法来处理的。 有很多大型开源项目的底层都基于 Etcd，举几个比较有名的工业级项目:kubernetes、 CoreDNS、ROOK&amp;hellip;&amp;hellip;
Etcd 的场景  服务发现。(可以把服务存储到某个 prefix 开头的 key中，然后消费端或者服务信息以调用， 同时消费者也可以通过 watch 获得 key 的变化) 消息分布和订阅 分布式锁 Leader 选举 分布式队列 负载均衡 &amp;hellip;&amp;hellip;  和 redis 的区别 面试的时候可能有面试官喜欢问，
 redis 的数据类型更丰富(string, hash, set ,zset, list)，etcd 仅仅就是 key-val。 etcd 的底层是 Raft 算法，可以保证数据的强一致性。而 redis 数据复制上是主备异步复制，只能最终一致性。 读写性能上，因为 etcd 保证强一致性，所以会比 redis 差。 存储方面，etcd 使用的是持久化存储boltdb，而 redis 的方案是可持久化的 aof/rdb -&amp;hellip;&amp;hellip;  环境与说明 直接下载编译好的二进制文件也好，还是自己下载源码编译运行，先开启一个单节点服务就行。我本地使用 goreman 搭建了三个实例。 这里稍微说明一下:PEER ADDRS 指的是向其他 etcd server 暴露的通信地址,比如上图 name=infra1 要调用 infra2， 调用的就是 http://127.</description>
    </item>
    
    <item>
      <title>etcd 实战基础篇(二) </title>
      <link>https://www.syst.top/posts/go/etcd-2021-04-15/</link>
      <pubDate>Sat, 10 Apr 2021 09:54:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/etcd-2021-04-15/</guid>
      <description>上一篇我们主要是介绍了 etcd 使用场景以及最基础性的一些操作(put get watch)。 这一篇我们接着实战etcd的一些应用。无论深入哪个开源项目，首先我们得先学会使用它们。
基于 etcd 的分布式锁 基于 etcd 实现一个分布式锁特别简单。etcd 提供了开箱即用的包 concurrency，几行代码就实现一个分布式锁。
package src import ( &amp;#34;context&amp;#34; &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/coreos/etcd/clientv3&amp;#34; &amp;#34;github.com/coreos/etcd/clientv3/concurrency&amp;#34; &amp;#34;log&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;time&amp;#34; ) var addr = flag.String(&amp;#34;addr&amp;#34;, &amp;#34;http://127.0.0.1:2379&amp;#34;, &amp;#34;etcd address&amp;#34;) // 初始化etcd客户端 func initEtcdClient() *clientv3.Client { var client *clientv3.Client var err error // 解析etcd的地址，编程[]string 	endpoints := strings.Split(*addr, &amp;#34;,&amp;#34;) // 创建一个 etcd 的客户端 	client, err = clientv3.New(clientv3.Config{Endpoints: endpoints, DialTimeout: 5 * time.Second}) if err != nil { fmt.</description>
    </item>
    
    <item>
      <title>使用 Go 每分钟处理百万请求 </title>
      <link>https://www.syst.top/posts/go/handle-million-requests/</link>
      <pubDate>Mon, 05 Apr 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/handle-million-requests/</guid>
      <description>介绍 偶然间看到一篇写于15年的文章，说实话，标题确实吸引了我，不过看了几遍之后，确实精彩。 关于这篇文章，我就不直接翻译了。 项目的需求就是 客户端发送请求，服务端接收请求处理数据(原文是把资源上传至 Amazon S3 资源中)。本质上就是这样, 我稍微改动了原文的业务代码，但是并不影响核心模块。在第一版中，每收到一个 Request,开启一个 G 进行处理，快速响应，很常规的操作。
代码如下
初版 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; ) type Payload struct { // 传啥不重要 } func (p *Payload) UpdateToS3() error { //存储逻辑,模拟操作耗时 	time.Sleep(500 * time.Millisecond) fmt.Println(&amp;#34;上传成功&amp;#34;) return nil } func payloadHandler(w http.ResponseWriter, r *http.Request) { // 业务过滤 	// 请求body解析...... 	var p Payload go p.UpdateToS3() w.Write([]byte(&amp;#34;操作成功&amp;#34;)) } func main() { http.HandleFunc(&amp;#34;/payload&amp;#34;, payloadHandler) log.Fatal(http.ListenAndServe(&amp;#34;:8099&amp;#34;, nil)) } 这样操作存在什么问题呢？一般情况下，没什么问题。但是如果是高并发的场景下，不对G数进行控制，你的 CPU 使用率暴涨，内存占用暴涨，直至程序奔溃。</description>
    </item>
    
    <item>
      <title>情绪管理 </title>
      <link>https://www.syst.top/lives/2021-04-10/</link>
      <pubDate>Mon, 05 Apr 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/2021-04-10/</guid>
      <description>为什么写这篇文章？
因为我本身并不是一个脾气很好的人，比较情绪化。
情绪管理的难度不亚于时间的管理。但是，在我看来两者之间有明显的不同点。我用一句话来总结:时间管理是下意识的，情绪管理是无意识的。呵，我都称之为管理了，可见以前被支配的恐惧。
犯脾气的场景很多，归根结底就是不爽了。
  自身利益受损
  被别人兑
  眼里容不得沙子
  被别人批评，极力维护自己
  女朋友跟人跑了(没那么惨吧？)
  当脾气上来的时候，往往是挡不住的。这时候容易说一些伤人的话，有时候挺致命的。
如果你也是一个脾气不好的人，我觉得以下几点可能会帮到你。
学会倾听别人的声音 有时候人往往喜欢活在自己的世界里，自认为自己都是对的，容不得他人发出一丁点声音。其实，这个世界存在很多声音。人活在这个世界上，首先要学会和各种各样的声音共存。
我一直喜欢一句话：我不同意你说话的内容，但是我维护你说话的权利。
学会承认错误 你有没有这样的时刻，明明是自己的错误，因为这个错误被他人批评，为了维护自己的自尊心，极力反抗，坚决维护自己，可就是没有承认错误的勇气。
承认自己的错误并不是一件丢人的事情。工作中，我们也理应主动的承担自己的过错，是自己的锅果断背及时背。当然，并不是要你把别人的锅也大包大揽。
学会说话过脑 你说这话都不过脑的吗？有时候情绪上来，双方接话会特别快，对话也越来越不友善，往往对方还未说完已经脱口而出针对术语了。这个过程简直比 CPU 处理速度快多了。回想一下，在冒犯别人的话即将脱口而出的时候，想把话咽回去是多么困难的一件事。
在&amp;laquo;思考快与慢&amp;raquo; 这本书中，作者杜撰出了两个角色:系统1和系统2。书中提到两个因素决定了人的思维活动:系统1 和系统 2。系统1是一种快思考，系统2则是慢思考。
系统1的运行往往是无意识且快速的，没有感觉，完全处于自主控制的状态。
系统2则是负责自我控制的。我们在审视自己的时候，往往采用的是系统2，在系统2的模式下，我们的头脑清晰，富有逻辑，善作抉择，能更好的决定自己该说什么，该做什么。
不要过于较真 应该没有人因为互相吐槽对方代码写的垃圾打起来的吧？如果有，请后台联系我。
生活工作中处处都是细节，细节决定一切这句话是有针对性的。要是放在无关紧要的事情上，细节就是魔鬼。
没必要因为不同意对方的观点而恼羞成怒，更没有必要在对方哑口无言的时候咄咄逼人。不要把话说死，也不要把事情做绝，凡事给别人留个台阶，总是没错的。
与人友善比聪明更重要 这也是我最信奉的一句话，希望你也喜欢:与人友善比聪明更重要。
以上是日常的一些总结的，你还有什么要补充的吗？欢迎下方留言交流。</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://www.syst.top/about/</link>
      <pubDate>Sat, 03 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.syst.top/about/</guid>
      <description>你好，我是吴亲库里，最近沉迷于 Golang,欢迎一起交流。
介绍： 18 年毕业于某不知名学校，开始走上php之路，20年9月跳槽新公司有幸接触 Golang,从此爱上了它。
联系方式：  Github：https://github.com/wuqinqiang 公众号：吴亲强的深夜食堂 邮箱：wuqinqiang050@gmail.com 微信:我画你猜   </description>
    </item>
    
    <item>
      <title>《待定》</title>
      <link>https://www.syst.top/k8s-categories/</link>
      <pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.syst.top/k8s-categories/</guid>
      <description>我的公众号 </description>
    </item>
    
    <item>
      <title>《待定》</title>
      <link>https://www.syst.top/prometheus-categories/</link>
      <pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.syst.top/prometheus-categories/</guid>
      <description>我的公众号 </description>
    </item>
    
    <item>
      <title>Kubernetes 本地快速启动（基于 Docker）</title>
      <link>https://www.syst.top/posts/kubernetes/2020-05-01-install/</link>
      <pubDate>Fri, 01 May 2020 11:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/kubernetes/2020-05-01-install/</guid>
      <description>Kubernetes 在容器编排大战结束后已经在云原生中占据了明确的一席，最近几年越来越火热，目前搜索趋势：
Kubernetes 的热度很明显是不断地在上涨，因此学习和使用 Kubernetes 是一件相对正确的事，同时公司大多都在往容器化上接近，在拥抱 Kubernetes，所以我们所开发的应用也总是跑在容器环境中。更甚的是，需要对接 Kubernetes API 来做一些功能的开发。
这个时候，我们就需要一个 Kubernetes 环境来进行开发和调试，但你准备开始时，又遇到了一个问题，虽然在 2020 年的现在，Kubernetes 的安装已经有了极大的简化，教程也满地跑，但 Kubernetes 的安装和运行依然有一定的要求，像我，就遇到了如下问题：
显然，我的小水管 Mac 承受不起，但是又需要对 Kubernetes 进行学习和使用，除了买云服务器，又或是再在台式机上搭虚拟机，还有没有什么办法呢。
非运维开发的情况下，入门级中最简单的方式就是采用 Docker 所提供的 Kubernetes 支持。
Docker for Mac/Windows with Kubernetes Docker 在 17.12.ce 起就提供了 Mac 版本的 Kubernetes Beta 支持，在初始使用上来说非常的方便。首先我们检查 Docker 的版本，点击 Docker -&amp;gt; Check for Updates 确保你的 Docker 在最新版本。
快速安装 Kubernetes 在升级完成后，我们可以点击 Docker -&amp;gt; Preferences -&amp;gt; Kubernetes，如下图：
你会发现存在三个选项，分别是：Enable Kubernete、Deploy Docker Stacks to Kubernetes by default、Show system containers (advanced)。</description>
    </item>
    
    <item>
      <title>《待定吧》</title>
      <link>https://www.syst.top/go-categories/</link>
      <pubDate>Tue, 21 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.syst.top/go-categories/</guid>
      <description>我不怎么喜欢左写写，右写写，因此总是在不知不觉中写了不少的系列教程，希望对你有所帮助，若要催更请关注公众号后私聊催。
  一：HTTP 应用
 「连载一」etcd(-) 「连载二」etcd （二） 「连载三」Gin搭建Blog API&amp;rsquo;s （二） 「连载四」Gin搭建Blog API&amp;rsquo;s （三）    二：gRPC 应用
  三：grpc+grpc-gateway 应用
  我的公众号 </description>
    </item>
    
  </channel>
</rss>
