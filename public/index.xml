<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>记得</title>
    <link>https://www.syst.top/</link>
    <description>Recent content on 记得</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sun, 09 May 2021 12:25:52 +0800</lastBuildDate><atom:link href="https://www.syst.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>如何成为一个更好的开发者</title>
      <link>https://www.syst.top/lives/to-better/</link>
      <pubDate>Sun, 09 May 2021 12:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/to-better/</guid>
      <description>真正的成功者是在练习中慢慢积累起来的。
你在看大佬文章的时候，也许已经意识到了这一点。看到他们在做的一些事情，你就会想:
我不知道这个人为了实现目标付出了多少努力。
编码也不例外。如果你想要成为一个顶尖的工程师，你必须时刻地练习你的技能。
我主要会这么做。
目标 这是个人的信念，它也许能引导着我的一生。无论是从个人的角度还是从职业生涯，我们总是需要每个阶段为自己设置一个的目标，然后去干掉它。
比如，你可以:
  创建一个你一直想要创建的应用程序。
  认真看完一本你想看的书并进行独立的输出和思考。
  学习一门自己感兴趣的语言，通过它实现一个功能也好，还是把之前老项目重写。
  列举公司项目或者自己项目中的缺陷、痛点，通过思考、查阅资料、设计方案、落地完善系统。(别和我吹牛你的系统没问题)
  参与开源
  &amp;hellip;&amp;hellip;
  定目标的时候，不要太过于抽象，最好是一个可视化的目标。
另外设置目标的难度应该是超过当前能力范围，但是这个幅度不能过大，否则会脱离实际意识，我们就会称之为:劝退师。
如果目标很庞大，那么就需要进行拆解，就和我们系统模块一样，可以进行划分。目标也一样，可以进行拆分。设置一个总周期，那么相应的，阶段任务也就出来了。
更重要的是这个过程，过程才是目标的意义所在。结果只是意料之中的附属品。你永远也不知道这个过程能给你带来什么？打通任督二脉也不是不可能。
有些话我还是挺喜欢的。种一棵树最好的时间是十年前，其次是现在。
对于编程来说，空想是最没用的，一定得通过不断的练习。另外，延迟满足感是一件很重要的事情，当你觉得自己越来越菜的时候，可能是你越来越强的时候。
为什么是可能呢？
因为，也许你是真的菜。
我记得初入职场的时候，忘记实现了一个什么功能性的东西，那时候觉得自己好牛逼，现在我只想说：草率了。
输出 在实现目标的同时，一定会遇上自己不会的，从不会到会到熟练掌握存在一个过程，它也是一个个阶段。每一个阶段你都需要去总结分析你所学到的技能，如何知道自己的掌握程度？那一定是输出。输出的方式很多，比如:
单纯写 blog 给自己看，但是只存在自己的认知。
社区写文章分享。帮助别人的同时，可能有人能指出你的问题，或者提供了不一样的角度。
通过掌握的知识点写程序或者应用到实际项目中。
组内分享。
开源社区线下分享。(估计已经是大佬级别了)
多看书多阅读开源代码 目前公众号内卷比较严重，加上你看别人的文章都是别人学习、吸收、总结的最终产物。对于某个不了解的知识点，还是需要先看一手的资料。在这个基础上，回头看作者的文章，也许会有不一样的体会。
另外一篇文章由于篇幅限制或者侧重点的选择，往往会比较片面。这时候更应该看书了。你能吸动 &amp;laquo;TCP/IP详解&amp;raquo;的书，你看不懂别人写的阉割版 TCP/IP 文章？
至于源码，我觉得得从实际出发，比如项目中使用到的优秀库或者最近任务涉及到的技能想看别人的实现。整体架构？底层原理？设计细节？为什么要这样设计？只有了解底层原理，用起来才能更加舒心。从使用到原理，说不定后面有对应的需求，还会进行扩展，提交 PR，一举成为 Contributor。
总结 编码不是彩票，并不能一夜暴富。它是一个缓慢的过程，如果你能每天坚持向着目标学习，也许短时间你看不到任何可视化的效果。但是一年，两年&amp;hellip;..，当你回头想想一年前的自己是不是个傻逼，你就看到成长了，话糙理不糙。
仅以此篇献给我自己，也献给迷茫的你。</description>
    </item>
    
    <item>
      <title>每个人都有自己的路要走 </title>
      <link>https://www.syst.top/lives/every-one/</link>
      <pubDate>Tue, 04 May 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/every-one/</guid>
      <description>这个五一，我回家了。主要原因是其中一个比我大三岁的发小结婚了。
说起发小，我的发小圈和别人可能不太一样。本质上我有两波发小，这主要是取决于我的成长背景。
我一岁的时候，由于爸妈要外出打工，就把我带到了阿姨家，委托阿姨来照顾我。这一照顾，就是五六年。上幼儿班的时候，我教书的大伯把我带回到自己家，不过一放暑假或者寒假的时候，我都会去阿姨家一呆就是上月，每次都需要爸妈生拉硬拽拖我回家。
这种背景下，就导致我发小变成了两波，一波是平时上学自己家这边的，一波就是放假阿姨家那边的。
阿姨自己有两个孩子，一个比我大七岁左右(哥哥)，一个比我大十来岁(姐姐)。很难想象当时阿姨是咋么把我们带大的。
阿姨家那边的发小主要是阿姨夫兄弟们的孩子加上他们村的玩伴。为了方便下面的讲述，暂且先标注他们的小名吧。主要有小革、小萍、小宇、小遥以及小伟。
什么叫发小？什么叫青梅竹马？我只能说，电视剧里演的发小场景都是弟弟。
小时候我们真的啥都干过，某些场景至今记忆犹新。印象最深刻的还是老哥(阿姨的孩子)初中的时候，大概考了个位数的成绩，而且还在学校惹事了。那一次老师直接带着我哥从学校回来，准备直接家访。
当时我阿姨不在家。然后老师写了一封信(小时候农村还真没手机)以及我哥的成绩单留下，并告知我们家长回来的时候把这些交给他们。然而我哥一直在旁边给我们打手势，意思就是等他们走后把这些都烧了。然后我、小萍以及小革真的在老师走后把信和成绩单烧了个精光，这件事给我留下了深刻的印象。
有点扯远了，继续介绍发小，我们从年纪大的开始说起。
小伟的年纪应该是最大的，比我大5岁左右，目前也是两个孩子的父亲。我记得我读初中的时候他已经是个高中生了。小伟也是这里面我最生疏的一个。在我高中之后就再也没联系了。过年去阿姨家拜年的时候也没见到。昨天简单的交流下，他毕业后一开始从事 python 开发，后来转型做了安全方面的工作。由于这个是最生疏的，所以了解的不是很多。
接下来是小萍。小萍是这里面唯一的异性。
小萍大我四岁，我读初中的时候她刚好初中毕业。从小对小萍的印象还是很深刻的。作为女孩子，从小没见过她留过长发。一手利落干脆的短发，看起来很清爽。小时候我和她经常吵架，她的言语很犀利，有时候就算是大人也会被气到。记忆中，小萍毕业后先是在银行柜台干过几年，后面出来自己捣鼓网店，这几年听说赚了不少钱。但是为人很低调，偶尔会在朋友圈发一些美食周边的东西。
接下来就是本次结婚的主人公，小革。
小革比我大三岁，在我高中的时候就去当兵了。当兵的末段家里给他在县城买了一套房子，当兵出来后， 19 年左右去了杭州，后面经人介绍认识了现在的女朋友，当然女朋友也是我们那的。19年6月份的时候，去他们租住的房子里吃过一段饭，那时候他在一家教育机构工作，岗位应该类似销售的形式，直到现在还在这家公司。20年的时候把县城房子卖了在杭州上了车，年初看房的时候，特意去他家里看了看，后面还是没选择买在他家附近，因为离我现在上班不是很方便。
接着小遥。小遥是我们这其中两个学霸之一。
小遥和小革是同龄，和小革是小学同学以及初中同学。长得很斯文，偏瘦。性格和我相似，比较偏内向。之前微信上有聊过，但是真的好几年没见过面了。昨天我到小革家的时候，他说马上就来了。在他来之前，小萍对我说，等他来了，你肯定认不出来。
事实也的确如此，整个人比以前大了一圈，所以容貌上有所改变。但是，依稀能从中寻找出以前的模样。
小遥高中就读于县里的重点高中。本科也是重点大学，本科之后又继续读了研究生。研究生毕业后来到杭州，目前在四大行之一做系统开发。
我很好奇在银行开发和互联网公司有什么不一样？然后就有了以下部分对话。
 我:平常在银行上班996吗? 小遥:我们平常不加班，很少很少情况下会加班。一般都是到点就走。(此处一万多点暴击) 我:你们银行系统是不是都是 Java 写的？ 小遥:是的。而且技术栈一般都比较老，还夹杂着一些内部自研的东西。很少会引入新技术。 我:因为你们关注的是系统的稳定性。 小遥:除了系统的稳定性，还有安全也特别重要。一般我们一个需求开发周期都是数月，不会像你们互联网那样，一周好几个迭代版本。 我:那平常你们提交代码，会有严格的 code review 吗？ 小遥:其实还好吧。除了一开始入职的时候可能会有，后面也没有那么严格吧。 &amp;hellip;&amp;hellip; 后面他就帮忙去了，因为和小革完全是同辈发小，所以他得端两天的菜。我吃完的时候问他，端菜累吗？他把围裙脱下来，给我说你来试试。我回了一句，我是客人，哈哈。  最后一个是小宇，小宇是我们这年纪最小的(98年)，我倒数第二。
当然，小宇的学习成绩也是我们这最好的。
小宇高中的时候也就读于小遥的那所重点高中，不过不同的是，高考的时候，小宇是当年我们县的文科状元。后面就读于一所 985&amp;amp;211 院校。不过文科的专业就业确实是门学问。他自己本身又不喜欢公务员的工作，然后在大一的时候就去报名考取注册会计师的证书(听说这个证书每年都能额外领到数目不小的钱)。
小宇毕业后，也来到杭州(大家都在杭州的原因之一是:杭州是离衢州最近的一个(准)一线城市)，目前在杭州一家会计事务所工作，还有一个谈了五年左右的女朋友，简直是人生赢家。
不过他比较有意思。我和他聊的时间比较长。
他说过最让我印象深刻的一句话是:我这个人，特别喜欢和别人比较。
我没有反驳他。但是看过我公众号的人都知道，我是最反对这句话的，人为什么一定要和别人比？
下面是和他的部分对话:
 我:你日常工作996吗？ 小宇:996？事务所里日常007状态，真的太忙了。 我:那我日常995，007感觉自己是个机器，没有时间停下来思考。 小宇:其实我也后悔过，当初大一的时候没转计算机专业，那时候也没这方面的意识，身边也没认识这样的人。如果当初没有把注册会计师考下来，我可能在毕业的时候什么都没。 我:也许当初转了你也后悔。可是，你现在也能转啊。 小宇:现在我觉得太晚了。 我:你98还怕晚？ 小宇:我证书都考下来了。现在我觉得，假如路有100米，我觉得我已经走了40米，很难回头换路了。 我:那你当初没想过考研吗？ 小宇:当初有想过，但是能考什么？我看了半天，也不知道能考哪个方向。文科专业就业性确实不太行，以至于公务员是大部分人的归宿。 那你打算这条路走下去了？没打算考公务员吗？  目前规划是这样的。不过杭州给我的感觉压力很大，老实说，要不是身边有女朋友，我还真不知道能不能坚持下去。女朋友在身边，压力大的时候，至少还有一个人能说话。至于公务员，可能只是 plan B。 &amp;hellip;&amp;hellip; 以上就是昨天和发小们的一些对话。也只有在这种场合下才能凑齐全部的人，尽管早已没了当年的乐趣。 最后，想对着我那些发小说一句:</description>
    </item>
    
    <item>
      <title>iota 在 Go 中的使用 </title>
      <link>https://www.syst.top/posts/go/enum/</link>
      <pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/enum/</guid>
      <description>介绍 Go 语言实际上没有直接支持枚举的关键字。一般我们都是通过 const + iota 实现枚举的能力。
有人要问了，为什么一定要使用枚举呢？stackoverflow 上有一个高赞的回答，如下:
You should always use enums when a variable (especially a method parameter) can only take one out of a small set of possible values. Examples would be things like type constants (contract status: &amp;quot;permanent&amp;quot;, &amp;quot;temp&amp;quot;, &amp;quot;apprentice&amp;quot;), or flags (&amp;quot;execute now&amp;quot;, &amp;quot;defer execution&amp;quot;). If you use enums instead of integers (or String codes), you increase compile-time checking and avoid errors from passing in invalid constants, and you document which values are legal to use.</description>
    </item>
    
    <item>
      <title>业务中，经常需要的工具(1)</title>
      <link>https://www.syst.top/posts/go/mr/</link>
      <pubDate>Wed, 21 Apr 2021 23:54:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/mr/</guid>
      <description>业务场景 在做任务开发的时候，你们一定会碰到以下场景:
场景1：在调用外部第三方接口的时候， 某些第三方我严重怀疑他们自己开发的接口从来没有用到自己的业务上， 然后你就会发现，一个需求你需要调用不同的接口，做数据组装。
场景2:一个应用首页可能依托于很多服务。那就涉及到在加载页面时需要同时请求多个服务的接口。 这一步往往是由后端统一调用组装数据再返回给前端，也就是所谓的 BFF(Backend For Frontend) 层。 调用这些服务往往没有前后的依赖关系，可以同时调用。
针对以上两种场景，假设在没有强依赖关系下，选择串行话调用，那么总耗时即:
time=s1+s2+....sn 按照当代秒入百万的有为青年，这么长时间早就把你祖宗十八代问候了一遍。
为了伟大的KPI，我们往往会选择并发的调用这些依赖接口。那么总耗时就是:
time=max(s1,s2,s3.....,sn) 当然开始堆业务的时候可以先串行化，等到上面的人着急的时候，亮出绝招。 这样，年底 PPT 就可以加上浓重的一笔流水账:为业务某个接口提高百分之XXX性能，间接产生XXX价值。
当然这一切的前提是，做老板不懂技术，做技术&amp;quot;懂&amp;quot;你。
言归正传,
如果修改成并发调用，你可能会这么写，
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) func main() { var wg sync.WaitGroup wg.Add(2) var userInfo *User var productList []Product go func() { defer wg.Done() userInfo, _ = getUser() }() go func() { defer wg.Done() productList, _ = getProductList() }() wg.Wait() fmt.Printf(&amp;#34;用户信息:%+v\n&amp;#34;, userInfo) fmt.Printf(&amp;#34;商品信息:%+v\n&amp;#34;, productList) } /********用户服务**********/ type User struct { Name string Age uint8 } func getUser() (*User, error) { time.</description>
    </item>
    
    <item>
      <title>在Go中你犯过的错</title>
      <link>https://www.syst.top/posts/go/mistake/</link>
      <pubDate>Wed, 21 Apr 2021 23:54:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/mistake/</guid>
      <description>在迭代器变量上使用 goroutine 这算高频吧。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) func main() { var wg sync.WaitGroup items := []int{1, 2, 3, 4, 5} for index, _ := range items { wg.Add(1) go func() { defer wg.Done() fmt.Printf(&amp;#34;item:%v\n&amp;#34;, items[index]) }() } wg.Wait() } 一个很简单的利用 sync.waitGroup 做任务编排的场景，看一下好像没啥问题，运行看看结果。
为啥不是1-5(当然不是顺序的)。
原因很简单，循环器中的 i 实际上是一个单变量，go func 里的闭包只绑定在一个变量上， 每个 goroutine 可能要等到循环结束才真正的运行，这时候运行的 i 值大概率就是5了, 没人能保证这个过程，有的只是手段。
正确的做法
func main() { var wg sync.WaitGroup items := []int{1, 2, 3, 4, 5} for index, _ := range items { wg.</description>
    </item>
    
    <item>
      <title>etcd 实战基础篇(二) </title>
      <link>https://www.syst.top/translations/go-concurrency-2021-04-20/</link>
      <pubDate>Tue, 20 Apr 2021 23:54:52 +0800</pubDate>
      
      <guid>https://www.syst.top/translations/go-concurrency-2021-04-20/</guid>
      <description></description>
    </item>
    
    <item>
      <title>etcd 实战基础篇(一) </title>
      <link>https://www.syst.top/posts/go/etcd-2021-04-10/</link>
      <pubDate>Sat, 10 Apr 2021 09:54:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/etcd-2021-04-10/</guid>
      <description>最近一直在看 etcd 相关的东西，为了不&amp;quot;白看&amp;quot;，加深理解，随即开启此系列的输出。
Etcd是什么 Etcd 是由 Go 编写的。它是一个强一致性的分布式键值存储，提供一种可靠的方式来存储需要由分布式系统或者机器集群访问的数据。 同时 Etcd 各节点中的通信是通过 Raft 一致性算法来处理的。 有很多大型开源项目的底层都基于 Etcd，举几个比较有名的工业级项目:kubernetes、 CoreDNS、ROOK&amp;hellip;&amp;hellip;
Etcd 的场景  服务发现。(可以把服务存储到某个 prefix 开头的 key中，然后消费端或者服务信息以调用， 同时消费者也可以通过 watch 获得 key 的变化) 消息分布和订阅 分布式锁 Leader 选举 分布式队列 负载均衡 &amp;hellip;&amp;hellip;  和 redis 的区别 面试的时候可能有面试官喜欢问，
 redis 的数据类型更丰富(string, hash, set ,zset, list)，etcd 仅仅就是 key-val。 etcd 的底层是 Raft 算法，可以保证数据的强一致性。而 redis 数据复制上是主备异步复制，只能最终一致性。 读写性能上，因为 etcd 保证强一致性，所以会比 redis 差。 存储方面，etcd 使用的是持久化存储boltdb，而 redis 的方案是可持久化的 aof/rdb -&amp;hellip;&amp;hellip;  环境与说明 直接下载编译好的二进制文件也好，还是自己下载源码编译运行，先开启一个单节点服务就行。我本地使用 goreman 搭建了三个实例。 这里稍微说明一下:PEER ADDRS 指的是向其他 etcd server 暴露的通信地址,比如上图 name=infra1 要调用 infra2， 调用的就是 http://127.</description>
    </item>
    
    <item>
      <title>etcd 实战基础篇(二) </title>
      <link>https://www.syst.top/posts/go/etcd-2021-04-15/</link>
      <pubDate>Sat, 10 Apr 2021 09:54:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/etcd-2021-04-15/</guid>
      <description>上一篇我们主要介绍了 etcd 使用场景以及最基础性的一些操作(put、get、watch)。 这一篇我们接着实战etcd其他业务场景。
基于 etcd 的分布式锁 基于 etcd 实现一个分布式锁特别简单。etcd 提供了开箱即用的包 concurrency，几行代码就实现一个分布式锁。
package src import ( &amp;#34;context&amp;#34; &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/coreos/etcd/clientv3&amp;#34; &amp;#34;github.com/coreos/etcd/clientv3/concurrency&amp;#34; &amp;#34;log&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;time&amp;#34; ) var addr = flag.String(&amp;#34;addr&amp;#34;, &amp;#34;http://127.0.0.1:2379&amp;#34;, &amp;#34;etcd address&amp;#34;) // 初始化etcd客户端 func initEtcdClient() *clientv3.Client { var client *clientv3.Client var err error // 解析etcd的地址，编程[]string 	endpoints := strings.Split(*addr, &amp;#34;,&amp;#34;) // 创建一个 etcd 的客户端 	client, err = clientv3.New(clientv3.Config{Endpoints: endpoints, DialTimeout: 5 * time.Second}) if err != nil { fmt.</description>
    </item>
    
    <item>
      <title>使用 Go 每分钟处理百万请求 </title>
      <link>https://www.syst.top/posts/go/handle-million-requests/</link>
      <pubDate>Mon, 05 Apr 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/handle-million-requests/</guid>
      <description>介绍 偶然间看到一篇写于15年的文章，说实话，标题确实吸引了我，不过看了几遍之后，确实精彩。 关于这篇文章，我就不直接翻译了。 项目的需求就是 客户端发送请求，服务端接收请求处理数据(原文是把资源上传至 Amazon S3 资源中)。本质上就是这样, 我稍微改动了原文的业务代码，但是并不影响核心模块。在第一版中，每收到一个 Request,开启一个 G 进行处理，快速响应，很常规的操作。
代码如下
初版 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; ) type Payload struct { // 传啥不重要 } func (p *Payload) UpdateToS3() error { //存储逻辑,模拟操作耗时 	time.Sleep(500 * time.Millisecond) fmt.Println(&amp;#34;上传成功&amp;#34;) return nil } func payloadHandler(w http.ResponseWriter, r *http.Request) { // 业务过滤 	// 请求body解析...... 	var p Payload go p.UpdateToS3() w.Write([]byte(&amp;#34;操作成功&amp;#34;)) } func main() { http.HandleFunc(&amp;#34;/payload&amp;#34;, payloadHandler) log.Fatal(http.ListenAndServe(&amp;#34;:8099&amp;#34;, nil)) } 这样操作存在什么问题呢？一般情况下，没什么问题。但是如果是高并发的场景下，不对G数进行控制，你的 CPU 使用率暴涨，内存占用暴涨，直至程序奔溃。</description>
    </item>
    
    <item>
      <title>情绪管理 </title>
      <link>https://www.syst.top/lives/2021-04-10/</link>
      <pubDate>Mon, 05 Apr 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/lives/2021-04-10/</guid>
      <description>为什么写这篇文章？
因为我本身并不是一个脾气很好的人，比较情绪化。
情绪管理的难度不亚于时间的管理。但是，在我看来两者之间有明显的不同点。我用一句话来总结:时间管理是下意识的，情绪管理是无意识的。呵，我都称之为管理了，可见以前被支配的恐惧。
犯脾气的场景很多，归根结底就是不爽了。
  自身利益受损
  被别人兑
  眼里容不得沙子
  被别人批评，极力维护自己
  女朋友跟人跑了(没那么惨吧？)
  当脾气上来的时候，往往是挡不住的。这时候容易说一些伤人的话，有时候挺致命的。
如果你也是一个脾气不好的人，我觉得以下几点可能会帮到你。
学会倾听别人的声音 有时候人往往喜欢活在自己的世界里，自认为自己都是对的，容不得他人发出一丁点声音。其实，这个世界存在很多声音。人活在这个世界上，首先要学会和各种各样的声音共存。
我一直喜欢一句话：我不同意你说话的内容，但是我维护你说话的权利。
学会承认错误 你有没有这样的时刻，明明是自己的错误，因为这个错误被他人批评，为了维护自己的自尊心，极力反抗，坚决维护自己，可就是没有承认错误的勇气。
承认自己的错误并不是一件丢人的事情。工作中，我们也理应主动的承担自己的过错，是自己的锅果断背及时背。当然，并不是要你把别人的锅也大包大揽。
学会说话过脑 你说这话都不过脑的吗？有时候情绪上来，双方接话会特别快，对话也越来越不友善，往往对方还未说完已经脱口而出针对术语了。这个过程简直比 CPU 处理速度快多了。回想一下，在冒犯别人的话即将脱口而出的时候，想把话咽回去是多么困难的一件事。
在&amp;laquo;思考快与慢&amp;raquo; 这本书中，作者杜撰出了两个角色:系统1和系统2。书中提到两个因素决定了人的思维活动:系统1 和系统 2。系统1是一种快思考，系统2则是慢思考。
系统1的运行往往是无意识且快速的，没有感觉，完全处于自主控制的状态。
系统2则是负责自我控制的。我们在审视自己的时候，往往采用的是系统2，在系统2的模式下，我们的头脑清晰，富有逻辑，善作抉择，能更好的决定自己该说什么，该做什么。
不要过于较真 应该没有人因为互相吐槽对方代码写的垃圾打起来的吧？如果有，请后台联系我。
生活工作中处处都是细节，细节决定一切这句话是有针对性的。要是放在无关紧要的事情上，细节就是魔鬼。
没必要因为不同意对方的观点而恼羞成怒，更没有必要在对方哑口无言的时候咄咄逼人。不要把话说死，也不要把事情做绝，凡事给别人留个台阶，总是没错的。
与人友善比聪明更重要 这也是我最信奉的一句话，希望你也喜欢:与人友善比聪明更重要。
以上是日常的一些总结的，你还有什么要补充的吗？欢迎下方留言交流。</description>
    </item>
    
  </channel>
</rss>
