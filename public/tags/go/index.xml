<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on 记得</title>
    <link>https://www.syst.top/tags/go/</link>
    <description>Recent content in go on 记得</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sun, 16 May 2021 00:17:52 +0800</lastBuildDate><atom:link href="https://www.syst.top/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>leetcode 213 House Robber II</title>
      <link>https://www.syst.top/leetcode/213-house-robbe-rii/</link>
      <pubDate>Sun, 16 May 2021 00:17:52 +0800</pubDate>
      
      <guid>https://www.syst.top/leetcode/213-house-robbe-rii/</guid>
      <description>介绍 这是 House Robber II，也就是 I 的变型版本。II 和 I 的最大区别在于 II 把房子围城一个圈了. 你可以理解成环形链表。这样对小偷打击还是蛮大的，这意味着第一幢房子和最后一幢房子是紧挨着的。不能同时偷。 之前我们提到，相邻两家不能同时偷。如果只有一家，那么根本构不成相邻的条件，就偷唯一的那户人家。 如果有两家，那么偷的必然是两家中钱多的那家。
那如果总数大于 2 家呢？
对于第 n 家来说，只有两种选择:偷或者不偷。
是咋么计算出当前这家是否要偷的呢。
我们假设当前这家编号为 n,那么
max(我偷第 n 家的钱 + sum(截止第 n-2 家偷的钱), sum(截止第 n-1 家偷的钱，因为既然 n-1 家偷了，那么 n 必然是不能偷了))。
这才是这道题关于动态规划最核心的一个点。
看懂了吗？没看懂也没关系，手把手摸个图片出来。 还没看懂，加我微信 remember_wuqinqiang 我告诉你。这里顺便打个广告，没加我好友的赶紧加我好友。
最后，还需要考虑一个问题，如何确保偷了第一家就不偷最后一家，偷最后一家就不偷第一家。 很简单，直接定义两个dp，一个范围不包括第一家，一个范围不包括最后一家。 最后我们变成了求:
// 伪代码 最佳偷钱:=max(dp[不包括第一家],dp[不包括最后一家]) 那么剩下的就是对两个dp的状态转移公式了。
func rob(nums []int) int { n := len(nums) if n == 0 { return 0 } if n == 1 { return nums[0] } dp1, dp2 := make([]int, n), make([]int, n) dp1[0] = nums[0] dp1[1] = max(dp1[0], nums[1]) dp2[0] = 0 //dp2 不算第一家了 	dp2[1] = max(dp2[0], nums[1]) for i := 2; i &amp;lt; n; i++ { if i &amp;lt; n-1 { // dp1 不算最后一家 	dp1[i] = max(dp1[i-1], dp1[i-2]+nums[i]) } else { dp1[i] = dp1[i-1] } dp2[i] = max(dp2[i-1], dp2[i-2]+nums[i]) } return max(dp2[n-1], dp1[n-1]) } func max(x int, y int) int { if x &amp;gt; y { return x } return y } 其实代码还能更简洁。</description>
    </item>
    
    <item>
      <title>iota 在 Go 中的使用 </title>
      <link>https://www.syst.top/posts/go/go-get-happen/</link>
      <pubDate>Thu, 13 May 2021 22:12:01 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/go-get-happen/</guid>
      <description></description>
    </item>
    
    <item>
      <title>iota 在 Go 中的使用 </title>
      <link>https://www.syst.top/posts/go/enum/</link>
      <pubDate>Sun, 25 Apr 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/enum/</guid>
      <description>介绍 Go 语言实际上没有直接支持枚举的关键字。一般我们都是通过 const + iota 实现枚举的能力。
有人要问了，为什么一定要使用枚举呢？stackoverflow 上有一个高赞的回答，如下:
You should always use enums when a variable (especially a method parameter) can only take one out of a small set of possible values. Examples would be things like type constants (contract status: &amp;quot;permanent&amp;quot;, &amp;quot;temp&amp;quot;, &amp;quot;apprentice&amp;quot;), or flags (&amp;quot;execute now&amp;quot;, &amp;quot;defer execution&amp;quot;). If you use enums instead of integers (or String codes), you increase compile-time checking and avoid errors from passing in invalid constants, and you document which values are legal to use.</description>
    </item>
    
    <item>
      <title>在Go中你犯过的错</title>
      <link>https://www.syst.top/posts/go/mistake/</link>
      <pubDate>Wed, 21 Apr 2021 23:54:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/mistake/</guid>
      <description>在迭代器变量上使用 goroutine 这算高频吧。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) func main() { var wg sync.WaitGroup items := []int{1, 2, 3, 4, 5} for index, _ := range items { wg.Add(1) go func() { defer wg.Done() fmt.Printf(&amp;#34;item:%v\n&amp;#34;, items[index]) }() } wg.Wait() } 一个很简单的利用 sync.waitGroup 做任务编排的场景，看一下好像没啥问题，运行看看结果。
为啥不是1-5(当然不是顺序的)。
原因很简单，循环器中的 i 实际上是一个单变量，go func 里的闭包只绑定在一个变量上， 每个 goroutine 可能要等到循环结束才真正的运行，这时候运行的 i 值大概率就是5了, 没人能保证这个过程，有的只是手段。
正确的做法
func main() { var wg sync.WaitGroup items := []int{1, 2, 3, 4, 5} for index, _ := range items { wg.</description>
    </item>
    
    <item>
      <title>如何优雅地实现并发编排任务</title>
      <link>https://www.syst.top/posts/go/mr/</link>
      <pubDate>Wed, 21 Apr 2021 23:54:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/mr/</guid>
      <description>业务场景 在做任务开发的时候，你们一定会碰到以下场景:
场景1：调用第三方接口的时候， 一个需求你需要调用不同的接口，做数据组装。 场景2:一个应用首页可能依托于很多服务。那就涉及到在加载页面时需要同时请求多个服务的接口。这一步往往是由后端统一调用组装数据再返回给前端，也就是所谓的 BFF(Backend For Frontend) 层。
针对以上两种场景，假设在没有强依赖关系下，选择串行调用，那么总耗时即:
time=s1+s2+....sn 按照当代秒入百万的有为青年，这么长时间早就把你祖宗十八代问候了一遍。
为了伟大的KPI，我们往往会选择并发地调用这些依赖接口。那么总耗时就是:
time=max(s1,s2,s3.....,sn) 当然开始堆业务的时候可以先串行化，等到上面的人着急的时候，亮出绝招。
这样，年底 PPT 就可以加上浓重的一笔流水账:为业务某个接口提高百分之XXX性能，间接产生XXX价值。
当然这一切的前提是，做老板不懂技术，做技术”懂”你。
言归正传,如果修改成并发调用，你可能会这么写，
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) func main() { var wg sync.WaitGroup wg.Add(2) var userInfo *User var productList []Product go func() { defer wg.Done() userInfo, _ = getUser() }() go func() { defer wg.Done() productList, _ = getProductList() }() wg.Wait() fmt.Printf(&amp;#34;用户信息:%+v\n&amp;#34;, userInfo) fmt.Printf(&amp;#34;商品信息:%+v\n&amp;#34;, productList) } /********用户服务**********/ type User struct { Name string Age uint8 } func getUser() (*User, error) { time.</description>
    </item>
    
    <item>
      <title>使用 Go 每分钟处理百万请求 </title>
      <link>https://www.syst.top/posts/go/handle-million-requests/</link>
      <pubDate>Mon, 05 Apr 2021 22:25:52 +0800</pubDate>
      
      <guid>https://www.syst.top/posts/go/handle-million-requests/</guid>
      <description>介绍 偶然间看到一篇写于15年的文章，说实话，标题确实吸引了我，不过看了几遍之后，确实精彩。 关于这篇文章，我就不直接翻译了。 项目的需求就是 客户端发送请求，服务端接收请求处理数据(原文是把资源上传至 Amazon S3 资源中)。本质上就是这样, 我稍微改动了原文的业务代码，但是并不影响核心模块。在第一版中，每收到一个 Request,开启一个 G 进行处理，快速响应，很常规的操作。
代码如下
初版 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; ) type Payload struct { // 传啥不重要 } func (p *Payload) UpdateToS3() error { //存储逻辑,模拟操作耗时 	time.Sleep(500 * time.Millisecond) fmt.Println(&amp;#34;上传成功&amp;#34;) return nil } func payloadHandler(w http.ResponseWriter, r *http.Request) { // 业务过滤 	// 请求body解析...... 	var p Payload go p.UpdateToS3() w.Write([]byte(&amp;#34;操作成功&amp;#34;)) } func main() { http.HandleFunc(&amp;#34;/payload&amp;#34;, payloadHandler) log.Fatal(http.ListenAndServe(&amp;#34;:8099&amp;#34;, nil)) } 这样操作存在什么问题呢？一般情况下，没什么问题。但是如果是高并发的场景下，不对G数进行控制，你的 CPU 使用率暴涨，内存占用暴涨，直至程序奔溃。</description>
    </item>
    
  </channel>
</rss>
