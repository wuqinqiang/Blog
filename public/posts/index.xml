<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on 记得</title>
		<link>https://www.syst.top/posts/</link>
		<description>Recent content in Posts on 记得</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Wed, 21 Apr 2021 23:54:52 +0800</lastBuildDate>
		<atom:link href="https://www.syst.top/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>在Go中你犯过的错</title>
			<link>https://www.syst.top/posts/go/mistake/</link>
			<pubDate>Wed, 21 Apr 2021 23:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/mistake/</guid>
			<description>在迭代器变量上使用 goroutine 这算高频吧。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) func main() { var wg sync.WaitGroup items := []int{1, 2, 3, 4, 5} for index, _ := range items { wg.Add(1) go func() { defer wg.Done() fmt.Printf(&amp;#34;item:%v\n&amp;#34;, items[index]) }() } wg.Wait() } 一个很简单的利用 sync.waitGroup 做任务编排的场景，看一下好像没啥问题，运行看看结果。
为啥不是1-5(当然不是顺序的)。
原因很简单，循环器中的 i 实际上是一个单变量，go func 里的闭包只绑定在一个变量上， 每个 goroutine 可能要等到循环结束才真正的运行，这时候运行的 i 值大概率就是5了, 没人能保证这个过程，有的只是手段。
正确的做法
func main() { var wg sync.WaitGroup items := []int{1, 2, 3, 4, 5} for index, _ := range items { wg.</description>
			<content type="html"><![CDATA[<h3 id="在迭代器变量上使用-goroutine">在迭代器变量上使用 goroutine</h3>
<p>这算高频吧。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">items</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v\n&#34;</span><span class="p">,</span> <span class="nx">items</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div><p>一个很简单的利用 <code>sync.waitGroup</code> 做任务编排的场景，看一下好像没啥问题，运行看看结果。</p>
<p><img src="https://image.syst.top/image/mistake/mistake-1.png" alt="image"></p>
<p>为啥不是1-5(当然不是顺序的)。</p>
<p>原因很简单，循环器中的 i 实际上是一个单变量，<code>go func</code>  里的闭包只绑定在一个变量上，
每个 <code>goroutine</code> 可能要等到循环结束才真正的运行，这时候运行的 i 值大概率就是5了,
没人能保证这个过程，有的只是手段。</p>
<p>正确的做法</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

	<span class="nx">items</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v\n&#34;</span><span class="p">,</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}(</span><span class="nx">index</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>通过将 <code>i</code>  作为一个参数传入闭包中，i 每次迭代都会被求值，
并放置在 <code>goroutine</code> 的堆栈中，因此每个切片元素最终都会被执行打印。</p>
<p>或者这样,道理是一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="nx">i</span><span class="o">:=</span><span class="nx">index</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v\n&#34;</span><span class="p">,</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}()</span>
	<span class="p">}</span>
</code></pre></div><h3 id="waitgroup">WaitGroup</h3>
<p>上面的例子有用到 <code>sync.waitGroup</code>，使用不当，也会犯错。</p>
<p>我把上面的例子稍微改动复杂一点点。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;github.com/prometheus/common/log&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">userId</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">userList</span> <span class="p">[]</span><span class="nx">User</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">userList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">userList</span><span class="p">,</span> <span class="nx">User</span><span class="p">{</span><span class="nx">userId</span><span class="p">:</span> <span class="nx">i</span><span class="p">})</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">userList</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">userList</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">log</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;err message:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	
	<span class="c1">// 处理其他事务
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">user</span> <span class="nx">User</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 处理杂七杂八的业务....
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">user</span><span class="p">.</span><span class="nx">userId</span> <span class="o">==</span> <span class="mi">9</span> <span class="p">{</span>
		<span class="c1">// 此人是非法用户
</span><span class="c1"></span>		<span class="k">return</span> <span class="s">&#34;失败&#34;</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;非法用户&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">&#34;成功&#34;</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>发现问题严重性了吗？</p>
<p>当用户<code>id</code>等于9的时候，<code>err !=nil</code> 直接 <code>return</code> 了，导致 <code>waitGroup</code> 计数器根本没机会减1，
最终 <code>wait</code> 会阻塞，多么可怕的 <code>bug</code>。</p>
<p>在绝大多数的场景下，我们都必须这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">userList</span> <span class="p">[]</span><span class="nx">User</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">userList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">userList</span><span class="p">,</span> <span class="nx">User</span><span class="p">{</span><span class="nx">userId</span><span class="p">:</span> <span class="nx">i</span><span class="p">})</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">userList</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>

			<span class="c1">//....业务代码
</span><span class="c1"></span>			<span class="c1">//....业务代码
</span><span class="c1"></span>			<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">userList</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">log</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;err message:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h3 id="野生-goroutine">野生 goroutine</h3>
<p>我不知道你们公司是咋么处理异步操作的，是下面这样吗</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// doSomething
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// doSomething
</span><span class="c1"></span>	<span class="p">}()</span>
<span class="p">}</span>
</code></pre></div><p>我们为了防止程序中出现不可预知的 <code>panic</code>，导致程序直接挂掉，都会加入 <code>recover</code>，比如这样</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;处理失败&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>但是如果这时候我们直接开启一个 <code>goroutine</code>，在这个 <code>goroutine</code> 里面发生了  <code>panic</code>，比如这样</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;处理失败&#34;</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>此时最外层的 <code>recover</code> 并不能捕获，程序会直接挂掉，就像下面这样。
<img src="https://image.syst.top/image/mistake/mistake-2.png" alt="image"></p>
<p>但是你总不能每次开启一个新的 <code>goroutine</code> 就在里面 <code>recover</code>,</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="c1">// func1
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}()</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;错误失败&#34;</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="c1">// func2
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}()</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;请求错误&#34;</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>所以基本上大家都会包一层。比如这样写,</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="c1">// func1
</span><span class="c1"></span>	<span class="nf">Go</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;错误失败&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="c1">// func2
</span><span class="c1"></span>	<span class="nf">Go</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;请求错误&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Go</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">go</span> <span class="nf">RunSafe</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">RunSafe</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;错误:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nf">fn</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>当然我这里只是简单都打印一些日志信息，一般还会带上堆栈都信息。</p>
<h3 id="channel">channel</h3>
<p><code>channel</code> 在 <code>go</code> 中的地位实在太高了，各大开源项目到处都是 <code>channel</code> 的影子，
以至于你在工业级的项目 issues 中搜索 <code>channel</code> ，能看到很多的 <code>bug</code>，
比如 etcd 这个 <code>issue</code>,
<img src="https://image.syst.top/image/mistake/mistake-3.png" alt="image"></p>
<p>一个往已关闭的 <code>channel</code> 中发送数据引发的 <code>panic</code>,等等类似场景很多。</p>
<p>这个故事告诉我们，否管大不大佬，改写的 <code>bug</code> 还是会写，手动狗头。</p>
<p><code>channel</code> 除了上述高频出现的错误，还有以下几点:</p>
<h4 id="直接关闭一个-nil-值-channel-会引发-panic">直接关闭一个 nil 值 channel 会引发 panic</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h4 id="关闭一个已关闭的-channel-会引发-panic">关闭一个已关闭的 channel 会引发 panic。</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>另外，有时候使用 <code>channel</code> 不小心会导致 <code>goroutine</code> 泄露，比如下面这种情况,</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="nx">cx</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;goroutine 结束&#34;</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;res&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">cx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;timeout&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><p>启动一个 <code>goroutine</code> 去处理业务，业务需要执行2秒，而我们设置的超时时间是1秒。
这就会导致 <code>channel</code> 从未被读取，
我们知道没有缓冲的 <code>channel</code> 必须等发送方和接收方都准备好才能操作。
此时 <code>goroutine</code> 会被永久阻塞在  <code>ch &lt;- struct{}{}</code> 这行代码，除非程序结束。
而这就是 <code>goroutine</code> 泄露。</p>
<p>解决这个也很简单，把无缓冲的 <code>channel</code> 改成缓冲为1。</p>
<h3 id="总结">总结</h3>
<p>这篇文章主要介绍了使用 <code>Go</code> 在日常开发中容易犯下的错。
当然还远远不止这些，你可以在下方留言中补充你犯过的错。</p>
]]></content>
		</item>
		
		<item>
			<title>etcd 实战基础篇(一) </title>
			<link>https://www.syst.top/posts/go/etcd-2021-04-10/</link>
			<pubDate>Sat, 10 Apr 2021 09:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/etcd-2021-04-10/</guid>
			<description>最近一直在看 etcd 相关的东西，为了不&amp;quot;白看&amp;quot;，加深理解，随即开启此系列的输出。
Etcd是什么 Etcd 是由 Go 编写的。它是一个强一致性的分布式键值存储，提供一种可靠的方式来存储需要由分布式系统或者机器集群访问的数据。 同时 Etcd 各节点中的通信是通过 Raft 一致性算法来处理的。 有很多大型开源项目的底层都基于 Etcd，举几个比较有名的工业级项目:kubernetes、 CoreDNS、ROOK&amp;hellip;&amp;hellip;
Etcd 的场景  服务发现。(可以把服务存储到某个 prefix 开头的 key中，然后消费端或者服务信息以调用， 同时消费者也可以通过 watch 获得 key 的变化) 消息分布和订阅 分布式锁 Leader 选举 分布式队列 负载均衡 &amp;hellip;&amp;hellip;  和 redis 的区别 面试的时候可能有面试官喜欢问，
 redis 的数据类型更丰富(string, hash, set ,zset, list)，etcd 仅仅就是 key-val。 etcd 的底层是 Raft 算法，可以保证数据的强一致性。而 redis 数据复制上是主备异步复制，只能最终一致性。 读写性能上，因为 etcd 保证强一致性，所以会比 redis 差。 存储方面，etcd 使用的是持久化存储boltdb，而 redis 的方案是可持久化的 aof/rdb -&amp;hellip;&amp;hellip;  环境与说明 直接下载编译好的二进制文件也好，还是自己下载源码编译运行，先开启一个单节点服务就行。我本地使用 goreman 搭建了三个实例。 这里稍微说明一下:PEER ADDRS 指的是向其他 etcd server 暴露的通信地址,比如上图 name=infra1 要调用 infra2， 调用的就是 http://127.</description>
			<content type="html"><![CDATA[<p>最近一直在看 etcd 相关的东西，为了不&quot;白看&quot;，加深理解，随即开启此系列的输出。</p>
<h3 id="etcd是什么">Etcd是什么</h3>
<p>Etcd 是由 Go 编写的。它是一个强一致性的分布式键值存储，提供一种可靠的方式来存储需要由分布式系统或者机器集群访问的数据。 同时 Etcd 各节点中的通信是通过 Raft 一致性算法来处理的。
有很多大型开源项目的底层都基于 Etcd，举几个比较有名的工业级项目:kubernetes、 CoreDNS、ROOK&hellip;&hellip;</p>
<h3 id="etcd-的场景">Etcd 的场景</h3>
<ul>
<li>服务发现。(可以把服务存储到某个 prefix 开头的 key中，然后消费端或者服务信息以调用， 同时消费者也可以通过 watch 获得 key 的变化)</li>
<li>消息分布和订阅</li>
<li>分布式锁</li>
<li>Leader 选举</li>
<li>分布式队列</li>
<li>负载均衡</li>
<li>&hellip;&hellip;</li>
</ul>
<h3 id="和-redis-的区别">和 redis 的区别</h3>
<p>面试的时候可能有面试官喜欢问，</p>
<ul>
<li>redis 的数据类型更丰富(string, hash, set ,zset, list)，etcd 仅仅就是 key-val。</li>
<li>etcd 的底层是 Raft 算法，可以保证数据的强一致性。而 redis 数据复制上是主备异步复制，只能最终一致性。</li>
<li>读写性能上，因为 etcd 保证强一致性，所以会比 redis 差。</li>
<li>存储方面，etcd 使用的是持久化存储boltdb，而 redis 的方案是可持久化的 aof/rdb
-&hellip;&hellip;</li>
</ul>
<h3 id="环境与说明">环境与说明</h3>
<p>直接下载编译好的二进制文件也好，还是自己下载源码编译运行，先开启一个单节点服务就行。我本地使用 goreman 搭建了三个实例。
<img src="https://image.syst.top/image/etcd/peer.png" alt="image">
这里稍微说明一下:<code>PEER ADDRS</code> 指的是向其他 <code>etcd server</code> 暴露的通信地址,比如上图 <code>name=infra1</code> 要调用 <code>infra2</code>，
调用的就是 <code>http://127.0.0.1:22380</code>。 而 <code>CLIENT ADDRS</code> 是对客户端暴露的地址。比如接下来我们的客户端连接的是 <code>infra1</code>，使用的就是 <code>http://127.0.0.1:2379</code>。</p>
<p>目前网上的教程大多使用编译好的 etcdctl 这样的二进制文件，通过命令行来进行操作,简单直观。比如:
<img src="https://image.syst.top/image/etcd/etcd-ctl.png" alt="image"></p>
<p>但是也会导致一个问题，你并不知道客户端底层是如何运行的，这中间又涉及了哪些接口，对应的数据结构是什么样的。 所以为了一步步深入 etcd，我们从代码层面操作 etcd 客户端。</p>
<p>以下是本篇文章涉及到的全部代码,下面我们开始分块讲解.</p>
<h3 id="初始化-etcd-客户端">初始化 etcd 客户端</h3>
<p>我们先初始化一个 etcd 客户端</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">cli</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>

<span class="c1">// 初始化etcd 客户端
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="c1">// 解析etcd的地址，编程[]string
</span><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
	<span class="c1">// 创建一个 etcd 的客户端
</span><span class="c1"></span>	<span class="nx">cli</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="put-操作">put 操作</h3>
<p>命令行 <code>etcdctl put key val</code> 对应操作</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 设置key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">PutKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">PutResponse</span>
	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 key 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%v\n&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>除了简单的设置，我们还有一种租约模式，也就是设置一个key的有效期，在有效期之内可以进行续租，如果没续租到期就过期。 对应的命令行是分两段:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">etcdctl</span> <span class="nx">lease</span> <span class="nx">grant</span> <span class="mi">200</span>
<span class="c1">// lease 326978bac638650a granted with TTL(200s)
</span><span class="c1"></span><span class="nx">etcdctl</span> <span class="nx">put</span> <span class="nx">hello</span> <span class="nx">world</span> <span class="o">--</span><span class="nx">lease</span><span class="p">=</span><span class="mi">326978</span><span class="nx">bac638650a</span>
</code></pre></div><p>对应操作</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 设置会过期的key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">PutKeyLease</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ttl</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">PutResponse</span>

	<span class="c1">// 创建一个租约对象
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">lease</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nx">Lease</span>
	<span class="nx">lease</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">NewLease</span><span class="p">(</span><span class="nx">cli</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">leaseResp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">LeaseGrantResponse</span>
	<span class="c1">// 根据时间，生成一个租约
</span><span class="c1"></span>	<span class="nx">leaseResp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">lease</span><span class="p">.</span><span class="nf">Grant</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">ttl</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 租约 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithLease</span><span class="p">(</span><span class="nx">leaseResp</span><span class="p">.</span><span class="nx">ID</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 key 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%v\n&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>etcd 的租约模式，简单的说， 当 Lease server 收到 client 请求，比如上面创建一个有效期200秒的请求，会通过 Raft
模块完成日志同步， 随后 Apply 模块的 Grant 接口执行日志条目内容。这是后续我们要研究的，这里略微提一下。</p>
<p>首先你得创建一个 Lease(租约)，获取到一个 Lease 唯一id，然后 put 的时候带上这个 id。当一个 key 指定一个 Lease 的时候，
底层最终是会把这个 key 关联到 Lease 的内存集合中。所以本质上，一个 Lease 可以 关联 n 个 key。而我们平常使用的缓存 key 设置过期时间，一般是把 key 和过期时间一对一绑定。</p>
<p>可能有人还要问，Lease 到期了是如何删除掉关联的 key？</p>
<p>其实原理说起来也很简单。Lease 在底层存储的结构是堆。由一个异步的 G 专门负责的去淘汰过期的 Lease。定时从最小堆中取出已经到期的 Lease。 然后删除 Lease 以及 删除通过 LeaseId 关联上此 Lease 的
key 列表。后面我们分析源码的时候专门讨论这块。</p>
<p>这里我还要说一点，你可以看到，不管是 put 一个普通的 key，还是一个带有租约的 key，调用的都是同一个方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 普通的
</span><span class="c1"></span>	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
<span class="c1">// 租约
</span><span class="c1"></span>	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithLease</span><span class="p">(</span><span class="nx">leaseResp</span><span class="p">.</span><span class="nx">ID</span><span class="p">))</span>
	
<span class="c1">// 源码里面
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">OpOption</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Op</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">WithLease</span><span class="p">(</span><span class="nx">leaseID</span> <span class="nx">LeaseID</span><span class="p">)</span> <span class="nx">OpOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">op</span> <span class="o">*</span><span class="nx">Op</span><span class="p">)</span> <span class="p">{</span> <span class="nx">op</span><span class="p">.</span><span class="nx">leaseID</span> <span class="p">=</span> <span class="nx">leaseID</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">op</span> <span class="o">*</span><span class="nx">Op</span><span class="p">)</span> <span class="nf">applyOpts</span><span class="p">(</span><span class="nx">opts</span> <span class="p">[]</span><span class="nx">OpOption</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
		<span class="nf">opt</span><span class="p">(</span><span class="nx">op</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>看出来了吗？一个很常见的设计模式，装饰器。</p>
<h3 id="get-操作">Get 操作</h3>
<p>命令行 <code>etcdctl get key</code> 对应操作,</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">GetResponse</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;获取 key 失败 :%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key %v 的值是：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们都知道，etcd从 v3 开始，底层实现了 MVCC 机制。所以在 etcd 中的 key 是存在多个历史版本的。
我们会在命令行中 <code>etcdctl get hello --rev=?</code>,比如
<img src="https://image.syst.top/image/etcd/rev-1.png" alt="image">
可以看到，不同版本的 key(&ldquo;hello&rdquo;)的值是不一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 获取指定版本的key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetKeyByVersion</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">version</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">GetResponse</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithRev</span><span class="p">(</span><span class="nx">version</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;删除 key:%v 失败:%v&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;请求key:%v,请求版本:%v,获取结果：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">version</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
</code></pre></div><p>一样的套路。我们也可以运行这段代码演示一下。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">src</span><span class="p">.</span><span class="nf">GetKeyByVersion</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="nx">src</span><span class="p">.</span><span class="nf">GetKeyByVersion</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>
</code></pre></div><p><img src="https://image.syst.top/image/etcd/rev-2.png" alt="image">
其他参数暂时忽略，主要看 Kvs 里面的结果。</p>
<h3 id="watch-操作">Watch 操作</h3>
<p>命令行 <code>./etcdctl watch hello</code></p>
<p>为了避免客户端的反复轮询， etcd 提供了 event 机制。客户端可以订阅一系列的 event ，用于 watch 某些 key 。
当这些被 watch 的 key 更新时， etcd 就会通知客户端。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 监听key 变动
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WatchKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">watch</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nx">WatchChan</span>
	<span class="nx">watch</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Watch</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">watch</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key:%v变动通知：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;值:%+v\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">res</span><span class="p">.</span><span class="nx">Events</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div><p>可以从上面这段代码看出，watch 是通过 channel 的方式来进行通知的</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 开启一个 G
</span><span class="c1">//	go src.WatchKey(&#34;hello&#34;)
</span></code></pre></div><p>然后我们运行这段程序，在命令行上操作 hello 这个 key，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="p">.</span><span class="o">/</span><span class="nx">etcdctl</span> <span class="nx">lease</span> <span class="nx">grant</span> <span class="mi">30</span>
<span class="nx">lease</span> <span class="mi">326978</span><span class="nx">bac638651e</span> <span class="nx">granted</span> <span class="nx">with</span> <span class="nf">TTL</span><span class="p">(</span><span class="mi">30</span><span class="nx">s</span><span class="p">)</span>
<span class="p">.</span><span class="o">/</span><span class="nx">etcdctl</span> <span class="nx">put</span> <span class="nx">hello</span> <span class="nx">world</span><span class="o">-</span><span class="nx">age</span> <span class="o">--</span><span class="nx">lease</span><span class="p">=</span><span class="mi">326978</span><span class="nx">bac638651e</span>
</code></pre></div><p><img src="https://image.syst.top/image/etcd/watch.png" alt="image">
可以看到接收到两个事件，一个是 put，一个是租约到期 delete。</p>
<h3 id="总结">总结</h3>
<p>以下是这篇文章全部代码</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">src</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;strings&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">cli</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>

<span class="c1">// 初始化etcd 客户端
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="c1">// 解析etcd的地址，编程[]string
</span><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
	<span class="c1">// 创建一个 etcd 的客户端
</span><span class="c1"></span>	<span class="nx">cli</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 设置key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">PutKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">PutResponse</span>
	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 key 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%v\n&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 设置会过期的key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">PutKeyLease</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ttl</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">PutResponse</span>

	<span class="c1">// 创建一个租约对象
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">lease</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nx">Lease</span>
	<span class="nx">lease</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">NewLease</span><span class="p">(</span><span class="nx">cli</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">leaseResp</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">LeaseGrantResponse</span>
	<span class="c1">// 根据时间，生成一个租约
</span><span class="c1"></span>	<span class="nx">leaseResp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">lease</span><span class="p">.</span><span class="nf">Grant</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">ttl</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 租约 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithLease</span><span class="p">(</span><span class="nx">leaseResp</span><span class="p">.</span><span class="nx">ID</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;设置 key 失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%v\n&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 获取key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">GetResponse</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;获取 key 失败 :%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key %v 的值是：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 获取指定版本的key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetKeyByVersion</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">version</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">GetResponse</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithRev</span><span class="p">(</span><span class="nx">version</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;删除 key:%v 失败:%v&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;请求key:%v,请求版本:%v,获取结果：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">version</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 删除key
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DeleteKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="kd">var</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">DeleteResponse</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;删除 key:%v 失败:%v&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;操作结果：%+v\n&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 监听key 变动
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WatchKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">watch</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nx">WatchChan</span>
	<span class="nx">watch</span> <span class="p">=</span> <span class="nx">cli</span><span class="p">.</span><span class="nf">Watch</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithRev</span><span class="p">(</span><span class="mi">21</span><span class="p">))</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">watch</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key:%v变动通知：%+v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;值:%+v\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">res</span><span class="p">.</span><span class="nx">Events</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">}</span>

<span class="p">}</span>

</code></pre></div><p>这篇文章主要介绍了etcd这个分布式存储工具，包括它的应用场景以及实战基本的操作。
上面其实还有很多的实例没有写出来，一个是因为懒，没必要一个个演示一遍，另一个原因是留给你们自行实现。
我们以这个为开始，一步步敲开 etcd 的大门。</p>
]]></content>
		</item>
		
		<item>
			<title>etcd 实战基础篇(二) </title>
			<link>https://www.syst.top/posts/go/etcd-2021-04-15/</link>
			<pubDate>Sat, 10 Apr 2021 09:54:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/etcd-2021-04-15/</guid>
			<description>上一篇我们主要介绍了 etcd 使用场景以及最基础性的一些操作(put、get、watch)。 这一篇我们接着实战etcd其他业务场景。
基于 etcd 的分布式锁 基于 etcd 实现一个分布式锁特别简单。etcd 提供了开箱即用的包 concurrency，几行代码就实现一个分布式锁。
package src import ( &amp;#34;context&amp;#34; &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/coreos/etcd/clientv3&amp;#34; &amp;#34;github.com/coreos/etcd/clientv3/concurrency&amp;#34; &amp;#34;log&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;time&amp;#34; ) var addr = flag.String(&amp;#34;addr&amp;#34;, &amp;#34;http://127.0.0.1:2379&amp;#34;, &amp;#34;etcd address&amp;#34;) // 初始化etcd客户端 func initEtcdClient() *clientv3.Client { var client *clientv3.Client var err error // 解析etcd的地址，编程[]string 	endpoints := strings.Split(*addr, &amp;#34;,&amp;#34;) // 创建一个 etcd 的客户端 	client, err = clientv3.New(clientv3.Config{Endpoints: endpoints, DialTimeout: 5 * time.Second}) if err != nil { fmt.</description>
			<content type="html"><![CDATA[<p>上一篇我们主要介绍了 etcd 使用场景以及最基础性的一些操作(put、get、watch)。 这一篇我们接着实战etcd其他业务场景。</p>
<h3 id="基于-etcd-的分布式锁">基于 etcd 的分布式锁</h3>
<p>基于 etcd 实现一个分布式锁特别简单。etcd 提供了开箱即用的包 <code>concurrency</code>，几行代码就实现一个分布式锁。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">src</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
	<span class="s">&#34;github.com/coreos/etcd/clientv3/concurrency&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;strings&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>

<span class="c1">// 初始化etcd客户端
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">initEtcdClient</span><span class="p">()</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">client</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="c1">// 解析etcd的地址，编程[]string
</span><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
	<span class="c1">// 创建一个 etcd 的客户端
</span><span class="c1"></span>	<span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">client</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Lock</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">lockName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="c1">// 创建一个 session,如果程序宕机奔溃，etcd可以知道
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">NewSession</span><span class="p">(</span><span class="nx">client</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="c1">// 创建一个etcd  locker
</span><span class="c1"></span>	<span class="nx">locker</span> <span class="o">:=</span> <span class="nx">concurrency</span><span class="p">.</span><span class="nf">NewLocker</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;id：%v 尝试获取锁%v&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>
	<span class="nx">locker</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;id:%v取得锁%v&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>

	<span class="c1">// 模拟业务耗时
</span><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">300</span><span class="p">)</span>

	<span class="nx">locker</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;id:%v释放锁%v&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们再写个脚本运行，看看结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;etcd-test/src&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">lockName</span> <span class="p">=</span> <span class="s">&#34;locker-test&#34;</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nx">src</span><span class="p">.</span><span class="nf">Lock</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">lockName</span><span class="p">)</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>我们发起了10个并发抢同一个 key 锁的命令。运行结果如下，
<img src="https://image.syst.top/image/etcd/lock.png" alt="image"></p>
<p>从图片可以看到，同一时刻一定只有一个 G 得到锁，一个 G 获取到一个锁的前提一定是当前 key 未被锁。</p>
<p>有人要问了，当一个锁解开时，之前未获取到锁而发生等待的客户端谁先获取到这把锁？ 这个问题，我们后续分析原理的时候再揭晓。</p>
<p>说到分布式锁，不得不提起 redis。它有一个看似安全实际一点都不安全的分布式锁。它的命令模式是</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">set</span> <span class="nx">key</span> <span class="nx">value</span> <span class="p">[</span><span class="nx">EX</span> <span class="nx">seconds</span><span class="p">]</span> <span class="p">[</span><span class="nx">PX</span> <span class="nx">milliseconds</span><span class="p">]</span> <span class="p">[</span><span class="nx">NX</span><span class="p">|</span><span class="nx">XX</span><span class="p">]</span>
</code></pre></div><p>这其中，介绍两个关键的属性:</p>
<ul>
<li>EX 标示设置过期时间，单位是秒。</li>
<li>NX 表示 当对应的 key 不存在时，才创建。</li>
</ul>
<p>我们在使用 redis 做分布式锁的时候会这么写。(代码用了包 <code>https://github.com/go-redis/redis</code>)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RedisLock</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rdb</span> <span class="p">=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Options</span><span class="p">{</span>
		<span class="nx">Addr</span><span class="p">:</span>     <span class="s">&#34;127.0.0.1:6379&#34;</span><span class="p">,</span>
		<span class="nx">Password</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
		<span class="nx">DB</span><span class="p">:</span>       <span class="mi">0</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 尝试获取锁,时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">rdb</span><span class="p">.</span><span class="nf">SetNX</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">,</span> <span class="s">&#34;value&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">res</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 尝试获取锁失败\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 获取到锁,时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="c1">//模拟业务耗时
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 释放锁，时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
	<span class="nx">rdb</span><span class="p">.</span><span class="nf">Del</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">rdb</span><span class="p">.</span><span class="nf">SetNX</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">,</span> <span class="s">&#34;value&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</code></pre></div><p>我们规定锁的过期时间是2秒，下面有一句 <code>time.Sleep(1 * time.Second) </code> 用来模拟处理业务的耗时。业务处理结束，我们删除 key <code>rdb.Del(ctx, &quot;key&quot;)</code> 。</p>
<p>我们写个简单的脚本，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nf">RedisLock</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>我们开启十个 G 并发的调用 <code>RedisLock</code> 函数。每次调用，函数内部都会新建一个 redis 客户端，本质上是10个客户端。</p>
<p>运行这段程序，</p>
<p><img src="https://image.syst.top/image/redis/lock-1.png" alt="image"></p>
<p>从图中看出，同一时刻只有一个客户端获取到锁，并且在一秒的任务处理后，释放了锁，好像没太大的问题。</p>
<p>那么，我再写一个简单的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/go-redis/redis/v8&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">ctx</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
<span class="kd">var</span> <span class="nx">rdb</span> <span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Client</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nf">ExampleLock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nf">ExampleLock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">ExampleLock</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">timeSleep</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rdb</span> <span class="p">=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Options</span><span class="p">{</span>
		<span class="nx">Addr</span><span class="p">:</span>     <span class="s">&#34;127.0.0.1:6379&#34;</span><span class="p">,</span>
		<span class="nx">Password</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
		<span class="nx">DB</span><span class="p">:</span>       <span class="mi">0</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">timeSleep</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="nx">timeSleep</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 尝试获取锁,时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">rdb</span><span class="p">.</span><span class="nf">SetNX</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">,</span> <span class="s">&#34;value&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">res</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:尝试获取锁失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 获取到锁,时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">7</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;item:%v 释放锁，时间:%v\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">String</span><span class="p">())</span>
	<span class="nx">rdb</span><span class="p">.</span><span class="nf">Del</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;key&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们设置锁的过期时间是 3 秒，而获取锁之后的任务处理时间为 7 秒。</p>
<p>然后我们开启两个 G。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">ExampleLock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nf">ExampleLock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div><p>其中第二行数字5，从代码中可以看出，是指启动 G 后过5秒去获取锁。</p>
<p>这段代码整体流程是这样的:G(1) 获取到锁后，设置的锁持有时间是3秒，由于任务执行需要7秒的时间，因此在3秒过后锁会自动释放。
G(2) 可以在第5秒的时候获取到锁，然后它执行任务也得7秒。最后，G(1)在获取锁后7秒执行释放锁的操作，G(2)同理。</p>
<p><img src="https://image.syst.top/image/redis/lock-2.png" alt="image"></p>
<p>发现问题了吗？</p>
<p>G(1) 的锁在3秒后已经自动释放了。但是在任务处理结束后又执行了解锁的操作,可此时这个锁是 G(2) 的呀。</p>
<p>那么接下来由于 G(1) 误解了 G(2) 的锁，如果此时有其他的 G，那么就可以获取到锁。</p>
<p>等 G(2) 任务执行结束，同理又会误解其他 G 的锁，这是一个恶性循环。
这也是掘金一篇由 redis 分布式锁造成茅台超卖重大事故的原因之一。</p>
<p>至于其他的，可以自行查看这篇文章[1]。</p>
<h3 id="基于-etcd-的分布式队列">基于 etcd 的分布式队列</h3>
<p>对队列更多的理论知识就不加以介绍了。我们都知道，队列是一种先进先出的数据结构，一般也只有入队和出队两种操作。
我们常常在单机的应用中使用到队列。</p>
<p>那么，如何实现一个分布式的队列呢?。</p>
<p>我们可以使用 etcd 开箱即用的工具，在 <code>etcd</code> 底层 <code>recipe</code> 包里结构 <code>Queue</code>，实现了一个多读多写的分布式队列。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Queue</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">client</span> <span class="o">*</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Client</span>
	<span class="nx">ctx</span>    <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>

	<span class="nx">keyPrefix</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">NewQueue</span><span class="p">(</span><span class="nx">client</span> <span class="o">*</span><span class="nx">v3</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">keyPrefix</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Queue</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">Queue</span><span class="p">)</span> <span class="nf">Dequeue</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">Queue</span><span class="p">)</span> <span class="nf">Enqueue</span><span class="p">(</span><span class="nx">val</span> <span class="kt">string</span><span class="p">)</span>

</code></pre></div><p>我们基于此包可以很方便的实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">src</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
	<span class="nx">recipe</span> <span class="s">&#34;github.com/coreos/etcd/contrib/recipes&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;strings&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>

<span class="c1">// 初始化etcd客户端
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">initEtcdClient</span><span class="p">()</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">client</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="c1">// 解析etcd的地址，编程[]string
</span><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
	<span class="c1">// 创建一个 etcd 的客户端
</span><span class="c1"></span>	<span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">client</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Push</span><span class="p">(</span><span class="nx">keyName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">recipe</span><span class="p">.</span><span class="nf">NewQueue</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">keyName</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
				<span class="nx">err</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;push err:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}(</span><span class="nx">j</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Pop</span><span class="p">(</span><span class="nx">keyName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">recipe</span><span class="p">.</span><span class="nf">NewQueue</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">keyName</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">Dequeue</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;接收值:%v\n&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>在 <code>push</code> 中，我们开启3轮发送值入队，每次发送10个，发送一轮休息2秒。
在 <code>pop</code> 中，通过死循环获取队列中的值。</p>
<p>运行脚本程序如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;etcd-test/src&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="s">&#34;test-queue&#34;</span>
	<span class="k">go</span> <span class="nx">src</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="k">go</span> <span class="nx">src</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">20</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们使用两个 <code>G</code> 代表 分别运行 <code>push</code> 和 <code>pop</code> 操作。
同时为了达到运行效果，我们先运行 <code>pop</code> 等待有入队的元素。
运行结果动画如下,</p>
<p><img src="https://image.syst.top/image/etcd/queue.gif" alt="image"></p>
<p><code>etcd</code> 还提供了优先级的分布式的队列。和上面的用法相似。只是在入队的时候，不仅仅需要提供一个值，还需要提供一个整数，来表示当前 <code>push</code> 值的优先级。数值越小，优先级越高。</p>
<p>我们改动一下上述的代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">src</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/coreos/etcd/clientv3&#34;</span>
	<span class="nx">recipe</span> <span class="s">&#34;github.com/coreos/etcd/contrib/recipes&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;strings&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;addr&#34;</span><span class="p">,</span> <span class="s">&#34;http://127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="s">&#34;etcd address&#34;</span><span class="p">)</span>

<span class="c1">// 初始化etcd客户端
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">initEtcdClient</span><span class="p">()</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">client</span> <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="c1">// 解析etcd的地址，编程[]string
</span><span class="c1"></span>	<span class="nx">endpoints</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
	<span class="c1">// 创建一个 etcd 的客户端
</span><span class="c1"></span>	<span class="nx">client</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Endpoints</span><span class="p">:</span> <span class="nx">endpoints</span><span class="p">,</span>
		<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始化客户端失败:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">client</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">PriorityPush</span><span class="p">(</span><span class="nx">keyName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">recipe</span><span class="p">.</span><span class="nf">NewPriorityQueue</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">keyName</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nx">err</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">item</span><span class="p">),</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;push err:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}(</span><span class="nx">j</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">PriorityPop</span><span class="p">(</span><span class="nx">keyName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">client</span> <span class="o">:=</span> <span class="nf">initEtcdClient</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">recipe</span><span class="p">.</span><span class="nf">NewPriorityQueue</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">keyName</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">q</span><span class="p">.</span><span class="nf">Dequeue</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;接收值:%v\n&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然后以下是我们的测试代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;etcd-test/src&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="s">&#34;test-queue&#34;</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nx">src</span><span class="p">.</span><span class="nf">PriorityPush</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="k">go</span> <span class="nx">src</span><span class="p">.</span><span class="nf">PriorityPop</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">20</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><p>我们把0到9的数并发的 <code>push</code> 到队列中，对应的优先级整数值就是它本身，<code>push</code> 完毕，我们运行 <code>PriorityPop</code> 函数，看最终结果显示就是从0到9。</p>
<p><img src="https://image.syst.top/image/etcd/queue-2.gif" alt="image"></p>
<h3 id="总结">总结</h3>
<p>这篇文章主要介绍了如何使用 etcd 实现分布式锁以及分布式队列。其他etcd的场景，可以自行实践。</p>
<h3 id="附录">附录</h3>
<p>[1]
<a href="https://juejin.cn/post/6854573212831842311">https://juejin.cn/post/6854573212831842311</a></p>
]]></content>
		</item>
		
		<item>
			<title>使用 Go 每分钟处理百万请求 </title>
			<link>https://www.syst.top/posts/go/handle-million-requests/</link>
			<pubDate>Mon, 05 Apr 2021 22:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/go/handle-million-requests/</guid>
			<description>介绍 偶然间看到一篇写于15年的文章，说实话，标题确实吸引了我，不过看了几遍之后，确实精彩。 关于这篇文章，我就不直接翻译了。 项目的需求就是 客户端发送请求，服务端接收请求处理数据(原文是把资源上传至 Amazon S3 资源中)。本质上就是这样, 我稍微改动了原文的业务代码，但是并不影响核心模块。在第一版中，每收到一个 Request,开启一个 G 进行处理，快速响应，很常规的操作。
代码如下
初版 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; ) type Payload struct { // 传啥不重要 } func (p *Payload) UpdateToS3() error { //存储逻辑,模拟操作耗时 	time.Sleep(500 * time.Millisecond) fmt.Println(&amp;#34;上传成功&amp;#34;) return nil } func payloadHandler(w http.ResponseWriter, r *http.Request) { // 业务过滤 	// 请求body解析...... 	var p Payload go p.UpdateToS3() w.Write([]byte(&amp;#34;操作成功&amp;#34;)) } func main() { http.HandleFunc(&amp;#34;/payload&amp;#34;, payloadHandler) log.Fatal(http.ListenAndServe(&amp;#34;:8099&amp;#34;, nil)) } 这样操作存在什么问题呢？一般情况下，没什么问题。但是如果是高并发的场景下，不对G数进行控制，你的 CPU 使用率暴涨，内存占用暴涨，直至程序奔溃。</description>
			<content type="html"><![CDATA[<h3 id="介绍">介绍</h3>
<p>偶然间看到一篇写于15年的文章，说实话，标题确实吸引了我，不过看了几遍之后，确实精彩。 关于这篇文章，我就不直接翻译了。 项目的需求就是 客户端发送请求，服务端接收请求处理数据(原文是把资源上传至 Amazon S3 资源中)。本质上就是这样,
<img src="https://image.aabbccm.com/image/handle-million.png" alt="image"></p>
<p>我稍微改动了原文的业务代码，但是并不影响核心模块。在第一版中，每收到一个 Request,开启一个 G 进行处理，快速响应，很常规的操作。</p>
<p>代码如下</p>
<h3 id="初版">初版</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Payload</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 传啥不重要
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Payload</span><span class="p">)</span> <span class="nf">UpdateToS3</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">//存储逻辑,模拟操作耗时
</span><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;上传成功&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">payloadHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 业务过滤
</span><span class="c1"></span>	<span class="c1">// 请求body解析......
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">Payload</span>
	<span class="k">go</span> <span class="nx">p</span><span class="p">.</span><span class="nf">UpdateToS3</span><span class="p">()</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;操作成功&#34;</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/payload&#34;</span><span class="p">,</span> <span class="nx">payloadHandler</span><span class="p">)</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8099&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div><p>这样操作存在什么问题呢？一般情况下，没什么问题。但是如果是高并发的场景下，不对G数进行控制，你的 CPU 使用率暴涨，内存占用暴涨，直至程序奔溃。</p>
<p>如果此操作落地至数据库，例如mysql,那么相应的，你数据库的服务器磁盘IO、网络带宽
、CPU负载、内存消耗都会达到非常高的情况，一并奔溃。所以，一旦程序中出现不可控的事物，往往是危险的信号。</p>
<h3 id="中版">中版</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">MaxQueue</span> <span class="p">=</span> <span class="mi">400</span>

<span class="kd">var</span> <span class="nx">Queue</span> <span class="kd">chan</span> <span class="nx">Payload</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">Queue</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Payload</span><span class="p">,</span> <span class="nx">MaxQueue</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Payload</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 传啥不重要
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Payload</span><span class="p">)</span> <span class="nf">UpdateToS3</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">//存储逻辑,模拟操作耗时
</span><span class="c1"></span>	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;上传成功&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">payloadHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 业务过滤
</span><span class="c1"></span>	<span class="c1">// 请求body解析......
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">Payload</span>
	<span class="c1">//go p.UpdateToS3()
</span><span class="c1"></span>	<span class="nx">Queue</span> <span class="o">&lt;-</span> <span class="nx">p</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;操作成功&#34;</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// 处理任务
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">StartProcessor</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">payload</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">Queue</span><span class="p">:</span>
			<span class="nx">payload</span><span class="p">.</span><span class="nf">UpdateToS3</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/payload&#34;</span><span class="p">,</span> <span class="nx">payloadHandler</span><span class="p">)</span>
	<span class="c1">//单独开一个g接收与处理任务
</span><span class="c1"></span>	<span class="k">go</span> <span class="nf">StartProcessor</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8099&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>这一版借助带 buffered 的 channel 来完成这个功能，这样控制住了无限制的G，但是依然没有解决问题。</p>
<p>处理请求是一个同步的操作，每次只会处理一个任务，然而高并发下请求进来的速度远远超过了处理的速度。这种情况，一旦 channel
满了之后， 后续的请求将会被阻塞等地啊。然后你会发现，响应的时间会大幅度的开始增加， 甚至不再有任何的响应。</p>
<h3 id="终版">终版</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
<span class="s">&#34;fmt&#34;</span>
<span class="s">&#34;log&#34;</span>
<span class="s">&#34;net/http&#34;</span>
<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">MaxWorker</span> <span class="p">=</span> <span class="mi">100</span> <span class="c1">//随便设置值
</span><span class="c1"></span>	<span class="nx">MaxQueue</span>  <span class="p">=</span> <span class="mi">200</span> <span class="c1">// 随便设置值
</span><span class="c1"></span><span class="p">)</span>

<span class="c1">// 一个可以发送工作请求的缓冲 channel
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">JobQueue</span> <span class="kd">chan</span> <span class="nx">Job</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">JobQueue</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">MaxQueue</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Payload</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">type</span> <span class="nx">Job</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">PayLoad</span> <span class="nx">Payload</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Worker</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">WorkerPool</span> <span class="kd">chan</span> <span class="kd">chan</span> <span class="nx">Job</span>
	<span class="nx">JobChannel</span> <span class="kd">chan</span> <span class="nx">Job</span>
	<span class="nx">quit</span>       <span class="kd">chan</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewWorker</span><span class="p">(</span><span class="nx">workerPool</span> <span class="kd">chan</span> <span class="kd">chan</span> <span class="nx">Job</span><span class="p">)</span> <span class="nx">Worker</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">Worker</span><span class="p">{</span>
		<span class="nx">WorkerPool</span><span class="p">:</span> <span class="nx">workerPool</span><span class="p">,</span>
		<span class="nx">JobChannel</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Job</span><span class="p">),</span>
		<span class="nx">quit</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Start 方法开启一个 worker 循环，监听退出 channel，可按需停止这个循环
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="nx">Worker</span><span class="p">)</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="c1">// 将当前的 worker 注册到 worker 队列中
</span><span class="c1"></span>			<span class="nx">w</span><span class="p">.</span><span class="nx">WorkerPool</span> <span class="o">&lt;-</span> <span class="nx">w</span><span class="p">.</span><span class="nx">JobChannel</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">job</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">w</span><span class="p">.</span><span class="nx">JobChannel</span><span class="p">:</span>
				<span class="c1">// 	真正业务的地方
</span><span class="c1"></span>				<span class="c1">//	模拟操作耗时
</span><span class="c1"></span>				<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;上传成功:%v\n&#34;</span><span class="p">,</span> <span class="nx">job</span><span class="p">)</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">w</span><span class="p">.</span><span class="nx">quit</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="nx">Worker</span><span class="p">)</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">w</span><span class="p">.</span><span class="nx">quit</span> <span class="o">&lt;-</span> <span class="kc">true</span>
	<span class="p">}()</span>
<span class="p">}</span>

<span class="c1">// 初始化操作
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Dispatcher</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 注册到 dispatcher 的 worker channel 池
</span><span class="c1"></span>	<span class="nx">WorkerPool</span> <span class="kd">chan</span> <span class="kd">chan</span> <span class="nx">Job</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewDispatcher</span><span class="p">(</span><span class="nx">maxWorkers</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Dispatcher</span> <span class="p">{</span>
	<span class="nx">pool</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">chan</span> <span class="nx">Job</span><span class="p">,</span> <span class="nx">maxWorkers</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Dispatcher</span><span class="p">{</span><span class="nx">WorkerPool</span><span class="p">:</span> <span class="nx">pool</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dispatcher</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 开始运行 n 个 worker
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">MaxWorker</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">worker</span> <span class="o">:=</span> <span class="nf">NewWorker</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">WorkerPool</span><span class="p">)</span>
		<span class="nx">worker</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">go</span> <span class="nx">d</span><span class="p">.</span><span class="nf">dispatch</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dispatcher</span><span class="p">)</span> <span class="nf">dispatch</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">job</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">JobQueue</span><span class="p">:</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">job</span> <span class="nx">Job</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// 尝试获取一个可用的 worker job channel，阻塞直到有可用的 worker
</span><span class="c1"></span>				<span class="nx">jobChannel</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">d</span><span class="p">.</span><span class="nx">WorkerPool</span>
				<span class="c1">// 分发任务到 worker job channel 中
</span><span class="c1"></span>				<span class="nx">jobChannel</span> <span class="o">&lt;-</span> <span class="nx">job</span>
			<span class="p">}(</span><span class="nx">job</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 接收请求，把任务筛入JobQueue。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">payloadHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">work</span> <span class="o">:=</span> <span class="nx">Job</span><span class="p">{</span><span class="nx">PayLoad</span><span class="p">:</span> <span class="nx">Payload</span><span class="p">{}}</span>
	<span class="nx">JobQueue</span> <span class="o">&lt;-</span> <span class="nx">work</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;操作成功&#34;</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 通过调度器创建worker，监听来自 JobQueue的任务
</span><span class="c1"></span>	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">NewDispatcher</span><span class="p">(</span><span class="nx">MaxWorker</span><span class="p">)</span>
	<span class="nx">d</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/payload&#34;</span><span class="p">,</span> <span class="nx">payloadHandler</span><span class="p">)</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8099&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>


</code></pre></div><p>最终采用的是两级 channel，一级是将用户请求数据放入到 chan Job 中，这个 channel job 相当于待处理的任务队列。</p>
<p>另一级用来存放可以处理任务的 work 缓存队列，类型为 chan chan Job。调度器把待处理的任务放入一个空闲的缓存队列当中，work 会一直处理它的缓存队列。通过这种方式，实现了一个 worker 池。大致画了一个图帮助理解
<img src="https://image.aabbccm.com/image/work-pool.png" alt="image"></p>
<p>首先我们在接收到一个请求后，创建 Job 任务，把它放入到任务队列中等待 work 池处理。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">payloadHandler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">work</span> <span class="o">:=</span> <span class="nx">Job</span><span class="p">{</span><span class="nx">PayLoad</span><span class="p">:</span> <span class="nx">Payload</span><span class="p">{}}</span>
	<span class="nx">JobQueue</span> <span class="o">&lt;-</span> <span class="nx">work</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;操作成功&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>调度器初始化work池后，在 dispatch 中，一旦我们接收到 JobQueue 的任务，就去尝试获取一个可用的 worker，分发任务给 worker 的 job channel 中。 注意这个过程不是同步的，而是每接收到一个 job，就开启一个 G 去处理。这样可以保证 JobQueue 不需要进行阻塞，对应的往 JobQueue 理论上也不需要阻塞地写入任务。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dispatcher</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 开始运行 n 个 worker
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">MaxWorker</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">worker</span> <span class="o">:=</span> <span class="nf">NewWorker</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">WorkerPool</span><span class="p">)</span>
		<span class="nx">worker</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">go</span> <span class="nx">d</span><span class="p">.</span><span class="nf">dispatch</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dispatcher</span><span class="p">)</span> <span class="nf">dispatch</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">job</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">JobQueue</span><span class="p">:</span>
			<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">job</span> <span class="nx">Job</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// 尝试获取一个可用的 worker job channel，阻塞直到有可用的 worker
</span><span class="c1"></span>				<span class="nx">jobChannel</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">d</span><span class="p">.</span><span class="nx">WorkerPool</span>
				<span class="c1">// 分发任务到 worker job channel 中
</span><span class="c1"></span>				<span class="nx">jobChannel</span> <span class="o">&lt;-</span> <span class="nx">job</span>
			<span class="p">}(</span><span class="nx">job</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这里&quot;不可控&quot;的 G 和上面还是又所不同的。仅仅极短时间内处于阻塞读 Chan 状态， 当有空闲的 worker 被唤醒，然后分发任务，整个生命周期远远短于上面的操作。</p>
<p>最后，强烈建议看一下原文，原文地址在：http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/</p>
<h3 id="最终方案">最终方案</h3>
]]></content>
		</item>
		
		<item>
			<title>Kubernetes 本地快速启动（基于 Docker）</title>
			<link>https://www.syst.top/posts/kubernetes/2020-05-01-install/</link>
			<pubDate>Fri, 01 May 2020 11:25:52 +0800</pubDate>
			
			<guid>https://www.syst.top/posts/kubernetes/2020-05-01-install/</guid>
			<description>Kubernetes 在容器编排大战结束后已经在云原生中占据了明确的一席，最近几年越来越火热，目前搜索趋势：
Kubernetes 的热度很明显是不断地在上涨，因此学习和使用 Kubernetes 是一件相对正确的事，同时公司大多都在往容器化上接近，在拥抱 Kubernetes，所以我们所开发的应用也总是跑在容器环境中。更甚的是，需要对接 Kubernetes API 来做一些功能的开发。
这个时候，我们就需要一个 Kubernetes 环境来进行开发和调试，但你准备开始时，又遇到了一个问题，虽然在 2020 年的现在，Kubernetes 的安装已经有了极大的简化，教程也满地跑，但 Kubernetes 的安装和运行依然有一定的要求，像我，就遇到了如下问题：
显然，我的小水管 Mac 承受不起，但是又需要对 Kubernetes 进行学习和使用，除了买云服务器，又或是再在台式机上搭虚拟机，还有没有什么办法呢。
非运维开发的情况下，入门级中最简单的方式就是采用 Docker 所提供的 Kubernetes 支持。
Docker for Mac/Windows with Kubernetes Docker 在 17.12.ce 起就提供了 Mac 版本的 Kubernetes Beta 支持，在初始使用上来说非常的方便。首先我们检查 Docker 的版本，点击 Docker -&amp;gt; Check for Updates 确保你的 Docker 在最新版本。
快速安装 Kubernetes 在升级完成后，我们可以点击 Docker -&amp;gt; Preferences -&amp;gt; Kubernetes，如下图：
你会发现存在三个选项，分别是：Enable Kubernete、Deploy Docker Stacks to Kubernetes by default、Show system containers (advanced)。</description>
			<content type="html"><![CDATA[<p>Kubernetes 在容器编排大战结束后已经在云原生中占据了明确的一席，最近几年越来越火热，目前搜索趋势：</p>
<p><img src="https://image.eddycjy.com/2583d073cc05df561c735564bb3e9e81.jpg" alt="image"></p>
<p>Kubernetes 的热度很明显是不断地在上涨，因此学习和使用 Kubernetes 是一件相对正确的事，同时公司大多都在往容器化上接近，在拥抱 Kubernetes，所以我们所开发的应用也总是跑在容器环境中。更甚的是，需要对接 Kubernetes API 来做一些功能的开发。</p>
<p>这个时候，我们就需要一个 Kubernetes 环境来进行开发和调试，但你准备开始时，又遇到了一个问题，虽然在 2020 年的现在，Kubernetes 的安装已经有了极大的简化，教程也满地跑，但 Kubernetes 的安装和运行依然有一定的要求，像我，就遇到了如下问题：</p>
<p><img src="https://image.eddycjy.com/9ee9dd19241bfc9099603abcc455787d.jpg" alt="image"></p>
<p>显然，我的小水管 Mac 承受不起，但是又需要对 Kubernetes 进行学习和使用，除了买云服务器，又或是再在台式机上搭虚拟机，还有没有什么办法呢。</p>
<p>非运维开发的情况下，入门级中最简单的方式就是采用 Docker 所提供的 Kubernetes 支持。</p>
<h2 id="docker-for-macwindows-with-kubernetes">Docker for Mac/Windows with Kubernetes</h2>
<p>Docker 在 17.12.ce 起就提供了 Mac 版本的 <a href="https://www.docker.com/blog/docker-mac-kubernetes/">Kubernetes Beta</a> 支持，在初始使用上来说非常的方便。首先我们检查 Docker 的版本，点击 Docker -&gt; Check for Updates 确保你的 Docker 在最新版本。</p>
<h2 id="快速安装-kubernetes">快速安装 Kubernetes</h2>
<p>在升级完成后，我们可以点击 Docker -&gt; Preferences -&gt; Kubernetes，如下图：</p>
<p><img src="https://image.eddycjy.com/85e953f790c6b6955aa307445a8cf67a.jpg" alt="image"></p>
<p>你会发现存在三个选项，分别是：Enable Kubernete、Deploy Docker Stacks to Kubernetes by default、Show system containers (advanced)。</p>
<p>一般我们只勾选 “Enable Kubernetes” 选项，如果你还想通过 <code>docker ps</code> 查看到 Kubernetes 的相关容器信息，那么还可以勾选 “Show system containers” 选项，在勾选完毕后点击右下角的 “Apply” 按钮就可以了。</p>
<p>这个时候 Docker Preferences 界面上的 Kubernetes 选项将会进入 <code>kubernetes is starting...</code> 状态，也就是在拉取各类镜像，需要一定的时间。</p>
<p>这一步有一点需要注意，Kubernetes 大多数的镜像都在国外，如果不翻墙你是无法正常下载的，就会导致一直阻塞在 <code>kubernetes is starting...</code>，等半天也没有响应，这种情况下你可以把镜像源改为国内，又或是参考 <a href="https://github.com/gotok8s/k8s-docker-desktop-for-mac">k8s-docker-desktop-for-mac</a> 项目来安装。</p>
<p>最后在安装完毕后，你可以检查 Docker Preferences 界面左下角的 Kubernetes 状态是否正常就可以了，如下图：</p>
<p><img src="https://image.eddycjy.com/2e626b97af3549deff1f693800bd1275.jpg" alt="image"></p>
<h2 id="安装-dashboard">安装 Dashboard</h2>
<p>在完成 Kubernetes 的安装后，我们需要安装 Dashboard，执行如下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml
</code></pre></div><p>该 Dashboard 对应 <a href="https://github.com/kubernetes/dashboard">kubernetes/dashboard</a> 项目，而所选择的版本号（兼容性问题），大家可以根据 Releases 中的 Compatibility 来进行选择，但一般不需要太在意，因为 Kubernetes 在 Dashboard 上的建设重心已经逐渐偏向 Promethues 体系了，因此在这一块是比较滞后的，如果想特别依赖 Dashboard 来进行分析，也可以自行选择一些成熟的开源产品。</p>
<p>在完成 <code>apply</code> 后，进行代理，执行如下命令：</p>
<pre><code>// 默认 8001 端口，若有需要可通过 --port=8080 进行指定
$ kubectl proxy
</code></pre><p>执行完毕完毕后，我们可以直接在通过浏览器访问 <code>http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/login</code> 地址，如下图：</p>
<p><img src="https://image.eddycjy.com/905246b8d5150f90282b2b56eaf6a5c8.jpg" alt="image"></p>
<h2 id="创建-serviceaccount">创建 ServiceAccount</h2>
<p>我们在本地创建一个 k8s-admin.yaml 文件，创建一个 ServiceAccount 和角色绑定关系，写入如下文件内容：</p>
<pre><code>apiVersion: v1
kind: ServiceAccount
metadata:
  name: dashboard-admin
  namespace: kube-system
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: dashboard-admin
subjects:
  - kind: ServiceAccount
    name: dashboard-admin
    namespace: kube-system
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io
</code></pre><p>获取管理员角色的 <code>secret</code> 名称：</p>
<pre><code>$ kubectl get secrets -n kube-system | grep dashboard-admin | awk '{print $1}'
dashboard-admin-token-dknqx
</code></pre><p>获取对应的管理员的 <code>token</code> 值：</p>
<pre><code>$ kubectl describe secret dashboard-admin-token-dknqx -n kube-system
Name:         dashboard-admin-token-dknqx
Namespace:    kube-system
Labels:       &lt;none&gt;
Annotations:  kubernetes.io/service-account.name: dashboard-admin
              kubernetes.io/service-account.uid: 2f817ddd-5802-4e8b-8c38-f4affc16a6fe

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1025 bytes
namespace:  11 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4tZGtucXgiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiMmY4MTdkZGQtNTgwMi00ZThiLThjMzgtZjRhZmZjMTZhNmZlIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmUtc3lzdGVtOmRhc2hib2FyZC1hZG1pbiJ9.NKa8OESUsvrolyxezo8w_auKr7jC94gmCm2ZyvQda5X1wOImYYqnH482sDPsQ5Y_V-RH2UD-4eBIuZP6gh0p50nxz-gPqEEPdRln_7osbRMCgcGzqajVo3bx7UOLTJC9ka9S-0rv5HYbn3yeVi6Pt4sVW5GF6KInDcbyyYgse5B_nySIpw4AjdWXNG0npLjneBCQWrVKAQSYYw2mLPZAPPjw6yjXnBvqZmtH1wyvCsKAXbZqBtTp7ddIVvtmveeBuELsX5yIzWqD7qhcpZz4v07FrsfqK0_QJ18BBDBGYMJaaoaK0h2pl_E9sIlAXoBCJ6ol_wwUzfuOshPo9adqww
</code></pre><p>如果已经熟悉了，可以直接通过组合命令直接获取 token 值：</p>
<pre><code>$ kubectl describe secret dashboard-admin-token-dknqx -n kube-system | grep -E '^token' | awk '{print $2}'
</code></pre><h2 id="登陆-dashboard">登陆 Dashboard</h2>
<p>最后我们将 <code>token</code> 保存并复制到 Kubernetes Dashboard 的仪表盘并登陆，我们就可以看到如下界面：</p>
<p><img src="https://image.eddycjy.com/980b8975a010b6321de4e87cb29fb009.jpg" alt="image"></p>
<h2 id="小结">小结</h2>
<p>我们又回到最初的问题，要学习和使用 Kubernetes，最快最正确的方式，那就是尽快的进行实践，因为本质上我们不是运维开发人员，部署环境的 Kubernetes 也大多不是由你亲自搭建，因为中小微会直接用某云厂商的 Kubernetes，大厂有专职的人员，也不愁这个问题。</p>
<p>因此尽快行动，完成迭代中的需求是我们的目的，等完成后，再回过头来一步步手动搭建 Kubernetes 也未尝不可，所以我认为 Docker for Mac/Windows with Kubernetes 在初级入门阶段是一个很好的安装和使用方法。</p>
]]></content>
		</item>
		
	</channel>
</rss>
